var documenterSearchIndex = {"docs":
[{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/validation.jl\"","category":"page"},{"location":"pages/t002_validation/#Tutorial-2:-Code-validation-1","page":"2 Code validation","title":"Tutorial 2: Code validation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"How to implement the method of manufactured solutions\nHow to perform a convergence test\nHow to define the discretization error\nHow to integrate error norms\nHow to generate Cartesian meshes in arbitrary dimensions","category":"page"},{"location":"pages/t002_validation/#Problem-statement-1","page":"2 Code validation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we show how to validate a code using the well known method of manufactured solutions. For the sake of simplicity, we consider the Poisson equation in the unit square Omegadoteq (01)^2 as a model problem,","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are going to consider two different manufactured solutions. On the one hand, we consider function u(x)=x_1+x_2, which can be exactly represented by the FE interpolation that we construct below. Thus, one expects that the obtained approximation error is near the machine precision. We are going to check that this is true in the code. On the other hand, we consider a function that cannot be captured exactly by the interpolation, namely u(x)=x_1^3 + x_2^3. Here, our goal is to confirm that the convergence order of the discretization error is the optimal one.","category":"page"},{"location":"pages/t002_validation/#Manufactured-solution-1","page":"2 Code validation","title":"Manufactured solution","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We start by defining the manufactured solution u(x) = x_1+x_2 and the source term f associated with it, namely fdoteq-Delta(x_1+x_2)=0.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Gridap\n\nu(x) = x[1] + x[2]\nf(x) = 0","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We also need to define the gradient of u since we will compute the H^1 error norm later. In that case, the gradient is simply defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇u(x) = VectorValue(1,1)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we have used the constructor VectorValue to build the vector that represents the gradient. However, we still need a final trick. We need to tell the Gridap library that the gradient of the function u is available in the function ∇u (at this moment u and ∇u are two standard Julia functions without any connection between them). This is done by adding an extra method to the function gradient (aka ∇) defined in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"import Gridap: ∇\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Now, it is possible to recover function ∇u from function u as ∇(u). You can check that the following expression evaluates to true.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(u) === ∇u","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note: the definition of the gradient is optional. If not provided, the gradient will be computed with automatic differentiation.","category":"page"},{"location":"pages/t002_validation/#Cartesian-mesh-generation-1","page":"2 Code validation","title":"Cartesian mesh generation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to discretize the geometry of the unit square, we use the Cartesian mesh generator available in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"domain = (0,1,0,1)\npartition = (4,4)\nmodel = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The type CartesianDiscreteModel is a concrete type that inherits from DiscreteModel, which is specifically designed for building Cartesian meshes. The CartesianDiscreteModel constructor takes a tuple containing limits of the box we want to discretize  plus a tuple with the number of cells to be generated in each direction (here 4 by 4 cells). Note that the CaresianDiscreteModel is implemented for arbitrary dimensions. For instance, the following lines build a CartesianDiscreteModel  for the unit cube (01)^3 with 4 cells per direction","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"domain3d = (0,1,0,1,0,1)\npartition3d = (4,4,4)\nmodel3d = CartesianDiscreteModel(domain3d,partition3d)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"You could also generate a mesh for the unit tesseract (01)^4 (i.e., the unit cube in 4D). Look how the 2D and 3D models are built and just follow the sequence.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Let us return to the 2D CartesianDiscreteModel that we have already constructed. You can inspect it by writing it into vtk format. Note that you can also print a 3D model, but not a 4D one. In the future, it would be cool to generate a movie from a 4D model, but this functionality is not yet implemented.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you open the generated files, you will see that the boundary vertices and facets are identified with the name \"boundary\". This is just what we need to impose the Dirichlet boundary conditions in this example.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"These are the vertices in the model","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and these the facets","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"As you can see in the pictures, the objects on the boundary are correctly tagged with the name \"boundary\".","category":"page"},{"location":"pages/t002_validation/#FE-approximation-1","page":"2 Code validation","title":"FE approximation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We compute a FE approximation of the Poisson problem above by following the steps detailed in the previous tutorial:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV0 = TestFESpace(model,reffe,conformity=:H1,dirichlet_tags=\"boundary\")\nU = TrialFESpace(V0,u)\n\ndegree = 2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)\n\na(u,v) = ∫( ∇(v)⊙∇(u) )*dΩ\nb(v) = ∫( v*f )*dΩ\n\nop = AffineFEOperator(a,b,U,V0)\n\nuh = solve(op)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we are imposing Dirichlet boundary conditions on the objects tagged as \"boundary\" and that we are using the manufactured solution u to construct the trial FE space. Not also that we are not explicitly constructing an Assembler object nor a FESolver. We are relying on default values.","category":"page"},{"location":"pages/t002_validation/#Measuring-the-discretization-error-1","page":"2 Code validation","title":"Measuring the discretization error","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Our goal is to check that the discratization error associated with the computed approximation uh is close to machine precision. To this end, the first step is to compute the discretization error, which is done as you would expect:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"e = u - uh","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Once the error is defined, you can, e.g., visualize it.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(Ω,\"error\",cellfields=[\"e\" => e])","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This generates a file called error.vtu. Open it with Paraview to check that the error is of the order of the machine precision.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"A more rigorous way of quantifying the error is to measure it with a norm. Here, we use the L^2 and H^1 norms, which are defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":" w _L^2^2 doteq int_Omega w^2  textdOmega quad\n w _H^1^2 doteq int_Omega w^2 + nabla w cdot nabla w  textdOmega","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to compute these norms, we use again the ∫ function and the integration measure dΩ, namely","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2 = sqrt(sum( ∫( e*e )*dΩ ))\neh1 = sqrt(sum( ∫( e*e + ∇(e)⋅∇(e) )*dΩ ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The expression ∫( fun )*dΩ returns an object storing the cell contributions of the integral of the given function fun.  To end up with the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are close to machine precision (as one would expect).","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"tol = 1.e-10\n@assert el2 < tol\n@assert eh1 < tol","category":"page"},{"location":"pages/t002_validation/#Convergence-test-1","page":"2 Code validation","title":"Convergence test","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We end up this tutorial by performing a convergence test, where we are going to use all the new concepts we have learned.  We will consider a manufactured solution that does not belong to the FE interpolation space. In this test, we expect to see the optimal convergence order of the FE discretization.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Here, we define the manufactured functions","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"p = 3\nu(x) = x[1]^p+x[2]^p\n∇u(x) = VectorValue(p*x[1]^(p-1),p*x[2]^(p-1))\nf(x) = -p*(p-1)*(x[1]^(p-2)+x[2]^(p-2))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Since we have redefined the valiables u, ∇u, and f, we need to execute these lines again","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(::typeof(u)) = ∇u\nb(v) = ∫( v*f )*dΩ","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to perform the convergence test, we write in a function all the code needed to perform a single computation and measure its error. The input of this function is the number of cells in each direction and the interpolation order. The output is the computed L^2 and H^1 error norms.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function run(n,k)\n\n  domain = (0,1,0,1)\n  partition = (n,n)\n  model = CartesianDiscreteModel(domain,partition)\n\n  reffe = ReferenceFE(lagrangian,Float64,k)\n  V0 = TestFESpace(model,reffe,conformity=:H1,dirichlet_tags=\"boundary\")\n  U = TrialFESpace(V0,u)\n\n  degree = 2*p\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,degree)\n\n  a(u,v) = ∫( ∇(v)⊙∇(u) )*dΩ\n  b(v) = ∫( v*f )*dΩ\n\n  op = AffineFEOperator(a,b,U,V0)\n\n  uh = solve(op)\n\n  e = u - uh\n\n  el2 = sqrt(sum( ∫( e*e )*dΩ ))\n  eh1 = sqrt(sum( ∫( e*e + ∇(e)⋅∇(e) )*dΩ ))\n\n  (el2, eh1)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The following function does the convergence test. It takes a vector of integers (representing the number of cells per direction in each computation) plus the interpolation order. It returns the L^2 and H^1 error norms for each computation as well as the corresponding cell size.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function conv_test(ns,k)\n\n  el2s = Float64[]\n  eh1s = Float64[]\n  hs = Float64[]\n\n  for n in ns\n\n    el2, eh1 = run(n,k)\n    h = 1.0/n\n\n    push!(el2s,el2)\n    push!(eh1s,eh1)\n    push!(hs,h)\n\n  end\n\n  (el2s, eh1s, hs)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are ready to perform the test! We consider several mesh sizes and interpolation order k=1 and k=2 (for k=3 the error will be close to machine precision, as before, except if you change the value of p above).","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2s1, eh1s1, hs = conv_test([8,16,32,64,128],1);\nel2s2, eh1s2, hs = conv_test([8,16,32,64,128],2);\nnothing #hide","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"With the generated data, we do the classical convergence plot.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Plots\n\nplot(hs,[el2s1 eh1s1 el2s2 eh1s2],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2 k=1\" \"H1 k=1\" \"L2 k=2\" \"H1 k=2\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you run the code in a notebook, you will see a figure like this one: (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The generated curves make sense. For a given interpolation order it is observed that the convergence of the H^1 error is slower that L^2 one whereas increasing the order makes convergence faster both in L^2 and in H^1. However, in order to be more conclusive, we need to compute the slope of these lines. It can be done with this little function that internally uses a linear regression.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function slope(hs,errors)\n  x = log10.(hs)\n  y = log10.(errors)\n  linreg = hcat(fill!(similar(x), 1), x) \\ y\n  linreg[2]\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The slopes for the L^2 error norm is computed as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,el2s1)\nslope(hs,el2s2)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 error norm as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,eh1s1)\nslope(hs,eh1s2)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If your run these lines in a notebook, you will see that the slopes for the L^2 and H^1 error norms are 2 and 1 for k=1 and 3 and 2 for k=2 respectively.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Congrats, another tutorial done!","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/hyperelasticity.jl\"","category":"page"},{"location":"pages/t005_hyperelasticity/#Tutorial-5:-Hyper-elasticity-1","page":"5 Hyper-elasticity","title":"Tutorial 5: Hyper-elasticity","text":"","category":"section"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"note: Note\nThis tutorial is under construction, but the code below is already functional.","category":"page"},{"location":"pages/t005_hyperelasticity/#Problem-statement-1","page":"5 Hyper-elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"using Gridap\nusing LineSearches: BackTracking","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Material parameters","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"const λ = 100.0\nconst μ = 1.0","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Deformation Gradient","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"F(∇u) = one(∇u) + ∇u'\n\nJ(F) = sqrt(det(C(F)))\n\n#Green strain\n\n#E(F) = 0.5*( F'*F - one(F) )\n\ndE(∇du,∇u) = 0.5*( ∇du⋅F(∇u) + (∇du⋅F(∇u))' )","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Right Cauchy-green deformation tensor","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"C(F) = (F')⋅F","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Constitutive law (Neo hookean)","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"function S(∇u)\n  Cinv = inv(C(F(∇u)))\n  μ*(one(∇u)-Cinv) + λ*log(J(F(∇u)))*Cinv\nend\n\nfunction dS(∇du,∇u)\n  Cinv = inv(C(F(∇u)))\n  _dE = dE(∇du,∇u)\n  λ*(Cinv⊙_dE)*Cinv + 2*(μ-λ*log(J(F(∇u))))*Cinv⋅_dE⋅(Cinv')\nend","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Cauchy stress tensor","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"σ(∇u) = (1.0/J(F(∇u)))*F(∇u)⋅S(∇u)⋅(F(∇u))'","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Model","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"domain = (0,1,0,1)\npartition = (20,20)\nmodel = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Define new boundaries","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"labels = get_face_labeling(model)\nadd_tag_from_tags!(labels,\"diri_0\",[1,3,7])\nadd_tag_from_tags!(labels,\"diri_1\",[2,4,8])","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup integration","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"degree = 2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Weak form","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"res(u,v) = ∫( (dE∘(∇(v),∇(u))) ⊙ (S∘∇(u)) )*dΩ\n\njac_mat(u,du,v) =  ∫( (dE∘(∇(v),∇(u))) ⊙ (dS∘(∇(du),∇(u))) )*dΩ\n\njac_geo(u,du,v) = ∫( ∇(v) ⊙ ( (S∘∇(u))⋅∇(du) ) )*dΩ\n\njac(u,du,v) = jac_mat(u,du,v) + jac_geo(u,du,v)","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Construct the FEspace","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"reffe = ReferenceFE(lagrangian,VectorValue{2,Float64},1)\nV = TestFESpace(model,reffe,conformity=:H1,dirichlet_tags = [\"diri_0\", \"diri_1\"])","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup non-linear solver","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"nls = NLSolver(\n  show_trace=true,\n  method=:newton,\n  linesearch=BackTracking())\n\nsolver = FESolver(nls)\n\nfunction run(x0,disp_x,step,nsteps,cache)\n\n  g0 = VectorValue(0.0,0.0)\n  g1 = VectorValue(disp_x,0.0)\n  U = TrialFESpace(V,[g0,g1])\n\n  #FE problem\n  op = FEOperator(res,jac,U,V)\n\n  println(\"\\n+++ Solving for disp_x $disp_x in step $step of $nsteps +++\\n\")\n\n  uh = FEFunction(U,x0)\n\n  uh, cache = solve!(uh,solver,op,cache)\n\n  writevtk(Ω,\"results_$(lpad(step,3,'0'))\",cellfields=[\"uh\"=>uh,\"sigma\"=>σ∘∇(uh)])\n\n  return get_free_dof_values(uh), cache\n\nend\n\nfunction runs()\n\n disp_max = 0.75\n disp_inc = 0.02\n nsteps = ceil(Int,abs(disp_max)/disp_inc)\n\n x0 = zeros(Float64,num_free_dofs(V))\n\n cache = nothing\n for step in 1:nsteps\n   disp_x = step * disp_max / nsteps\n   x0, cache = run(x0,disp_x,step,nsteps,cache)\n end\n\nend\n\n#Do the work!\nruns()","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Picture of the last load step (Image: )","category":"page"},{"location":"pages/t005_hyperelasticity/#Extension-to-3D-1","page":"5 Hyper-elasticity","title":"Extension to 3D","text":"","category":"section"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Extending this tutorial to the 3D case is straightforward. It is left as an exercise.","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: )","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"","category":"page"},{"location":"pages/t005_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/darcy.jl\"","category":"page"},{"location":"pages/t007_darcy/#Tutorial-7:-Darcy-equation-(with-RT)-1","page":"7 Darcy equation (with RT)","title":"Tutorial 7: Darcy equation (with RT)","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"How to implement multi-field PDEs\nHow to build div-conforming FE spaces\nHow to impose boundary conditions in multi-field problems","category":"page"},{"location":"pages/t007_darcy/#Problem-statement-1","page":"7 Darcy equation (with RT)","title":"Problem statement","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In this tutorial, we show how to solve a multi-field PDE in Gridap. As a model problem, we consider the Darcy equations with Dirichlet and Neumann boundary conditions. The PDE we want to solve is: find the flux vector u, and the pressure p such that","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"   leftlbrace\n   beginaligned\n      kappa^-1 u + nabla p = 0   textin  Omega\n      nabla cdot u = f   textin  Omega\n      u cdot n = g  texton  Gamma_rm D\n      p = h  texton Gamma_rm N\n   endaligned\n   right","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"being n the outwards unit normal vector to the boundary partialOmega.  In this particular tutorial, we consider the unit square Omega doteq (01)^2 as the computational domain, the Neumann boundary Gamma_rm N is the right and left sides of Omega, and Gamma_rm D is the bottom and top sides of Omega. We consider f = g doteq 0 and h(x) doteq x_1, i.e., h equal to 0 on the left side and 1 on the right side. The inverse of the permeability tensor, namely kappa^-1(x), is chosen equal to","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"beginpmatrix\n  100  90 \n  90  100\nendpmatrix\ntext for   x in 0406^2 text and \nbeginpmatrix\n  1  0 \n  0  1\nendpmatrix\n text\totherwise","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In order to state this problem in weak form, we introduce the following Sobolev spaces. H(mathrmdivOmega) is the space of vector fields in Omega, whose components and divergence are in L^2(Omega). On the other hand, H_g(mathrmdivOmega) and H_0(mathrmdivOmega) are the subspaces of functions in H(mathrmdivOmega) such that their normal traces are equal to g and 0 respectively almost everywhere in Gamma_rm D. With these notations, the weak form reads: find (up)in H_g(mathrmdivOmega)times L^2(Omega) such that a((up)(vq)) = b(vq) for all (vq)in H_0(mathrmdivOmega)times L^2(Omega), where","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"beginaligned\na((up)(vq)) doteq int_Omega  v cdot left(kappa^-1 uright)  rm dOmega - int_Omega (nabla cdot v) p  rm dOmega + int_Omega q (nabla cdot u)  rm dOmega\nb(vq) doteq int_Omega q f  rm  dOmega - int_Gamma_rm N (vcdot n) h   rm  dGamma\nendaligned","category":"page"},{"location":"pages/t007_darcy/#Numerical-scheme-1","page":"7 Darcy equation (with RT)","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In this tutorial, we use the Raviart-Thomas (RT)  space for the flux approximation [1]. On a reference square with sides aligned with the Cartesian axes, the RT space of order k is represented as Q_(k+1k) times Q_(kk+1), being the polynomial space defined as follows. The component  w_alpha of a vector field w in Q_(k+1k) times Q_(kk+1) is obtained as the tensor product of univariate polynomials of order k+1 in direction alpha times univariate polynomials of order k on the other directions. That is, nablacdot w in Q_k, where Q_k is the multivariate polynomial space of degree at most k in each of the spatial coordinates. Note that the definition of the RT space also applies to arbitrary dimensions. The global FE space for the flux V is obtained by mapping the cell-wise RT space into the physical space using the Piola transformation and enforcing continuity of normal traces across cells (see [1] for specific details).","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"We consider the subspace  V_0 of functions in V with zero normal trace on Gamma_rm D, and the subspace V_g of functions in V with normal trace equal to the projection of g onto the space of traces of V on Gamma_rm D. With regard to the pressure, we consider the discontinuous space of cell-wise polynomials in Q_k.","category":"page"},{"location":"pages/t007_darcy/#Discrete-model-1","page":"7 Darcy equation (with RT)","title":"Discrete model","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"We start the driver loading the Gridap package and constructing the geometrical model. We generate a 100times100 structured mesh for the domain (01)^2.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"using Gridap\ndomain = (0,1,0,1)\npartition = (100,100)\nmodel = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t007_darcy/#Multi-field-FE-spaces-1","page":"7 Darcy equation (with RT)","title":"Multi-field FE spaces","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"Next, we build the FE spaces. We consider the first order RT space for the flux and the discontinuous pressure space as described above.  This mixed FE pair satisfies the inf-sup condition and, thus, it is stable.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"order = 1\n\nV = FESpace(model, ReferenceFE(raviart_thomas,Float64,order),\n      conformity=:HDiv, dirichlet_tags=[5,6])\n\nQ = FESpace(model, ReferenceFE(lagrangian,Float64,order),\n      conformity=:L2)","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"Note that the Dirichlet boundary for the flux are the bottom and top sides of the squared domain (identified with the boundary tags 5, and 6 respectively), whereas no Dirichlet data can be imposed on the pressure space. We select conformity=:HDiv for the flux (i.e., shape functions with H^1(mathrmdivOmega) regularity) and conformity=:L2 for the pressure (i.e. discontinuous shape functions).","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"From these objects, we construct the trial spaces. Note that we impose homogeneous boundary conditions for the flux.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"uD = VectorValue(0.0,0.0)\nU = TrialFESpace(V,uD)\nP = TrialFESpace(Q)","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"When the singe-field spaces have been designed, the multi-field test and trial spaces are expressed as arrays of single-field ones in a natural way.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"Y = MultiFieldFESpace([V, Q])\nX = MultiFieldFESpace([U, P])","category":"page"},{"location":"pages/t007_darcy/#Numerical-integration-1","page":"7 Darcy equation (with RT)","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In this example we need to integrate in the interior of Omega and on the Neumann boundary Gamma_rm N. For the volume integrals, we extract the triangulation from the geometrical model and define the corresponding Lebesge measures, which will allow to write down the integrals of the weak form.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"trian = Triangulation(model)\ndegree = 2\ndΩ = Measure(trian,degree)","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In order to integrate the Neumann boundary condition, we only need to build an integration mesh for the right side of the domain (which is the only part of Gamma_rm N, where the Neumann function h is different from zero). Within the model, the right side of Omega is identified with the boundary tag 8. Using this identifier, we extract the corresponding surface triangulation and create the required Lebesge measure.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"neumanntags = [8,]\nbtrian = BoundaryTriangulation(model,tags=neumanntags)\ndΓ = Measure(btrian,degree)","category":"page"},{"location":"pages/t007_darcy/#Weak-form-1","page":"7 Darcy equation (with RT)","title":"Weak form","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"We start by defining the permeability tensors inverses commented above.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"const kinv1 = TensorValue(1.0,0.0,0.0,1.0)\nconst kinv2 = TensorValue(100.0,90.0,90.0,100.0)\nfunction σ(x,u)\n   if ((abs(x[1]-0.5) <= 0.1) && (abs(x[2]-0.5) <= 0.1))\n      return kinv2⋅u\n   else\n      return kinv1⋅u\n   end\nend","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"With this definition, we can express the integrand of the bilinear form as follows.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"px = get_physical_coordinate(trian)\n\na((u,p), (v,q)) = ∫(v⋅(σ∘(px,u)) - (∇⋅v)*p + q*(∇⋅u))dΩ","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"The arguments (u,p) and (v,q) of function a represent a trial and a test function, respectively. Notice that we unpack the functions directly from the multi-field test and trial spaces X and Y. E.g., v represents a test function for the flux and q for the pressure, which correspond to the first and second entries of Y. From the single-field functions, we write the different terms of the bilinear form as we have done in previous tutorials.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"In a similar way, we can define the forcing term related to the Neumann boundary condition.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"nb = get_normal_vector(btrian)\nh = -1.0\n\nb((v,q)) = ∫((v⋅nb)*h)dΓ","category":"page"},{"location":"pages/t007_darcy/#Multi-field-FE-problem-1","page":"7 Darcy equation (with RT)","title":"Multi-field FE problem","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"Finally, we can assemble the FE problem and solve it. Note that we build the AffineFEOperator object using the multi-field trial and test spaces Y and X.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"op = AffineFEOperator(a,b,X,Y)\nxh = solve(op)\nuh, ph = xh","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"Since this is a multi-field example, the solve function returns a multi-field solution xh, which can be unpacked in order to finally recover each field of the problem. The resulting single-field objects can be visualized as in previous tutorials (see next figure).","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"writevtk(trian,\"darcyresults\",cellfields=[\"uh\"=>uh,\"ph\"=>ph])","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"(Image: )","category":"page"},{"location":"pages/t007_darcy/#References-1","page":"7 Darcy equation (with RT)","title":"References","text":"","category":"section"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"[1] F. Brezzi and M. Fortin. Mixed and hybrid finite element methods. Springer-Verlag, 1991.","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"","category":"page"},{"location":"pages/t007_darcy/#","page":"7 Darcy equation (with RT)","title":"7 Darcy equation (with RT)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/poisson_dev_fe.jl\"","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Tutorial-13:-Low-level-API-Poisson-equation-1","page":"13 Low-level API Poisson equation","title":"Tutorial 13: Low-level API Poisson equation","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Introduction-and-caveat-1","page":"13 Low-level API Poisson equation","title":"Introduction and caveat","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This tutorial is advanced and you only need to go through this if you want to know the internals of Gridap and what it does under the hood. Even though you will likely want to use the high-level APIs in Gridap, this tutorial will (hopefully) help if you want to become a Gridap developer, not just a user. We also consider that this tutorial shows how powerful and expressive the Gridap kernel is, and how mastering it you can implement new algorithms not currently provided by the library.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As any other Gridap tutorial, this tutorial is primarily designed to be executed in a Jupyter notebook environment. However, the usage of a Julia debugger (typically outside of a Jupyter notebook environment), such as, e.g., the Julia REPL-based Debugger.jl package, or the one which comes along with the Visual Studio Code (VSCode) extension for the Julia programming language, may help the reader eager to understand the full detail of the explanations given. Some of the observations that come along with the code snippets are quite subtle/technical and may require a deeper exploration of the underlying code using a debugger.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Including-Gridap's-low-level-API-1","page":"13 Low-level API Poisson equation","title":"Including Gridap's low-level API","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us start including Gridap and some of its submodules, to have access to a rich set of not so high-level methods. Note that the module Gridap provides the high-level API, whereas the submodules such as, e.g., Gridap.FESpaces, provide access to the different parts of the low-level API.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"using Gridap\nusing Gridap.FESpaces\nusing Gridap.ReferenceFEs\nusing Gridap.Arrays\nusing Gridap.Geometry\nusing Gridap.Fields\nusing Gridap.CellData\nusing FillArrays\nusing Test\nusing InteractiveUtils","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Discrete-model-and-FE-spaces-set-up-using-high-level-API-1","page":"13 Low-level API Poisson equation","title":"Discrete model and FE spaces set up using high-level API","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We first create the geometry model and FE spaces using the high-level API. In this tutorial, we are not going to describe the geometrical machinery in detail, only what is relevant for the discussion. To simplify the analysis of the outputs, you can consider a 2D mesh, i.e., D=2 (everything below works for any spatial dimension without any extra complication). In order to make things slightly more interesting, i.e., having non-constant Jacobians, we have considered a mesh that is a stretching of an equal-sized structured mesh.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"L = 2 # Domain length in each space dimension\nD = 2 # Number of spatial dimensions\nn = 4 # Partition (i.e., number of cells per space dimension)\n\nfunction stretching(x::Point)\n   m = zeros(length(x))\n   m[1] = x[1]^2\n   for i in 2:D\n     m[i] = x[i]\n   end\n   Point(m)\nend\n\npmin = Point(Fill(0,D))\npmax = Point(Fill(L,D))\npartition = Tuple(Fill(n,D))\nmodel = CartesianDiscreteModel(pmin,pmax,partition,map=stretching)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The next step is to build the global FE space of functions from which we are going to extract the unknown function of the differential problem at hand. This tutorial explores the Galerkin discretization of the scalar Poisson equation. Thus, we need to build H1-conforming global FE spaces. This can be achieved using C^0 continuous functions made of piece(cell)-wise polynomials. This is precisely the purpose of the following lines of code.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"First, we build a scalar-valued (T = Float64) Lagrangian reference FE of order order atop a reference n-cube of dimension D. To this end, we first need to create a Polytope using an array of dimension D with the parameter HEX_AXIS, which encodes the reference representation of the cells in the mesh. Then, we create the Lagrangian reference FE using the reference geometry just created in the previous step. It is not the purpose of this tutorial to describe the (key) abstract concept of ReferenceFE in Gridap.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"T = Float64\norder = 1\npol = Polytope(Fill(HEX_AXIS,D)...)\nreffe = LagrangianRefFE(T,pol,order)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Second, we build the test (Vₕ) and trial (Uₕ) global finite element (FE) spaces out of model and reffe. At this point we also specify the notion of conformity that we are willing to satisfy, i.e., H1-conformity, and the region of the domain in which we want to (strongly) impose Dirichlet boundary conditions, the whole boundary of the box in this case.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Vₕ = FESpace(model,reffe;conformity=:H1,dirichlet_tags=\"boundary\")\nu(x) = x[1]            # Analytical solution (for Dirichlet data)\nUₕ = TrialFESpace(Vₕ,u)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#The-CellDatum-abstract-type-and-(some-of)-its-subtypes-1","page":"13 Low-level API Poisson equation","title":"The CellDatum abstract type and (some of) its subtypes","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We also want to extract the triangulation out of the model and create a numerical quadrature. We use a quadrature rule with a higher number integration points than those strictly needed to integrate a mass matrix exactly, i.e., 4*order, instead of 2*order We do so in order to help the reader distinguish the axis used for quadrature points, and the one used for DoFs in multi-dimensional arrays, which contain the result of evaluating fields (or a differential operator acting on these) in a set of quadrature rule evaluation points.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Tₕ = Triangulation(model)\nQₕ = CellQuadrature(Tₕ,4*order)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Qₕ is an instance of type CellQuadrature, a subtype of the CellDatum abstract data type.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"isa(Qₕ,CellDatum)\n\nsubtypes(CellDatum)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"CellDatum is the root of one out of three main type hierarchies in Gridap (along with the ones rooted at the abstract types Map and Field) on which the evaluation of variational methods in finite-dimensional spaces is grounded on. Any developer of Gridap should familiarize with these three hierarchies to some extent. Along this tutorial we will give some insight on the rationale underlying these, with some examples, but more effort in the form of self-research is expected from the reader as well.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Conceptually, an instance of a CellDatum represents a collection of quantities (e.g., points in a reference system, or scalar-, vector- or tensor-valued fields, or arrays made of these), once per each cell of a triangulation. Using the get_data generic function one can extract an array with such quantities. For example, in the case of Qₕ, we get an array of quadrature rules for numerical integration.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Qₕ_cell_data = get_data(Qₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test length(Qₕ_cell_data) == num_cells(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In this case we get the same quadrature rule in all cells (note that the returned array is of type Fill). Gridap also supports different quadrature rules to be used in different cells. Exploring such feature is out of scope of the present tutorial.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Any CellDatum has a trait, the so-called DomainStyle trait. This information is consumed by Gridap in different parts of the code. It specifies whether the quantities in it are either expressed in the reference (ReferenceDomain) or the physical (PhysicalDomain) domain. We can indeed check the DomainStyle of a CellDatum using the DomainStyle generic function:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"DomainStyle(Qₕ) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"DomainStyle(Qₕ) == PhysicalDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"If we evaluate the two expressions above, we can see that the DomainStyle trait of Qₕ is ReferenceDomain. This means that the local FE space in the physical space in which our problem is posed is expressed in terms of the composition of a space in a reference FE in a parametric space (which is being shared by many or all FEs in the physical space) and the inverse of the geometrical map (from the parametric to the physical space).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In practise, the integration in the physical space is transformed into a numerical integration in the reference space (via a change of variables) using a quadrature. We can exploit this property for ReferenceDomain FE spaces to reduce computations, i.e., to avoid applying the geometrical map to the quadrature points within Qₕ and its inverse at the shape functions in the physical space.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note that, while finite elements may not be defined in this parametric space (it is though standard practice with Lagrangian FEs, and other FEs, because of performance reasons), finite element functions are always integrated in such a parametric space. However, for FE spaces that are genuinely defined in the physical space, i.e., the ones with the PhysicalDomain trait, the transformation of quadrature points from the reference to the physical space is required.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In fact, the DomainStyle metadata of CellDatum allows Gridap to do the right thing (as soon as it is implemented) for all combinations of points and FE spaces (both either expressed in the reference or physical space). This is accomplished by the change_domain function in the API of CellDatum.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Using the array of quadrature rules Qₕ_cell_data, we can access specific entries. The object retrieved provides an array of points (Point data type in Gridap) in the cell reference parametric space 01^d and their corresponding weights.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"q = Qₕ_cell_data[rand(1:num_cells(Tₕ))]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"p = get_coordinates(q)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"w = get_weights(q)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"However, there is a more convenient way (for reasons made clear above) to work with the evaluation points of quadratures rules in Gridap. Namely, using the get_cell_points function we can extract a CellPoint object out of a CellQuadrature.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Qₕ_cell_point = get_cell_points(Qₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"CellPoint (just as CellQuadrature) is a subtype of CellDatum as well","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(Qₕ_cell_point, CellDatum)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"and thus we can ask for the value of its DomainStyle trait, and get an array of quantities out of it using the get_data generic function","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(Qₕ_cell_point) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"qₖ = get_data(Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Not surprisingly, the DomainStyle trait of the CellPoint object is ReferenceDomain, and we get a (cell) array with an array of Points per each cell out of a CellPoint. As seen in the sequel, CellPoints are relevant objects because they are the ones that one can use in order to evaluate the so-called CellField objects on the set of points of a CellPoint.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"CellField is an abstract type rooted at a hierarchy that plays a cornerstone role in the implementation of the finite element method in Gridap. At this point, the reader should keep in mind that the finite element method works with global spaces of functions which are defined piece-wise on each cell of the triangulation. In a nutshell (more in the sections below), a CellField, as it being a subtype of CellDatum, might be understood as a collection of Fields (or arrays made out them) per each triangulation cell. Field represents a field, e.g., a scalar, vector, or tensor field. Thus, the domain of a Field are points in the physical domain (represented by a type Point in Gridap, which is a VectorValue with a dimension matching that of the environment space) and the range is a scalar, vector (represented by VectorValue) or tensor (represented by TensorValue).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Unlike a plain array of Fields, a CellField is associated to a triangulation and is specifically designed having in mind FEs. For example, a global finite element function, or the collection of shape basis functions in the local FE space of each cell are examples of CellField objects. As commented above, these fields can be defined in the physical or a reference space (combined with a geometrical map provided by the triangulation object for each cell). Thus, CellField (as a sub-type of CellDatum) has the DomainStyle metadata that is used, e.g., for point-wise evaluations (as indicated above) of the fields and their derivatives (by implementing the transformations when taking a differential operators, e.g., the pull-back of the gradients).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Exploring-our-first-CellField-objects-1","page":"13 Low-level API Poisson equation","title":"Exploring our first CellField objects","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us work with our first CellField objects, namely FEBasis objects, and its evaluation. In particular, let us extract out of the global test space, Vₕ, and trial space, Uₕ, a collection of local test and trial finite element shape basis functions, respectively.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv = get_fe_basis(Vₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"du = get_trial_fe_basis(Uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The objects returned are of FEBasis type, one of the subtypes of CellField. Apart from DomainStyle, FEBasis objects also have an additional trait, BasisStyle, which specifies whether the cell-local shape basis functions are either of test or trial type (in the Galerkin method). This information is consumed in different parts of the code.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test Gridap.FESpaces.BasisStyle(dv) == Gridap.FESpaces.TestBasis()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test Gridap.FESpaces.BasisStyle(du) == Gridap.FESpaces.TrialBasis()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As expected, dv is made out of test shape functions, and du, of trial shape functions. We can also confirm that both dv and du are CellField and CellDatum objects (i.e., recall that FEBasis is a subtype of CellField, and the latter is a subtype of CellDatum).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(dv,CellField) && isa(dv,CellDatum)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(du,CellField) && isa(du,CellDatum)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Thus, one may check the value of their DomainStyle trait.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(dv) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(du) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can see that the DomainStyle of both FEBasis objects is ReferenceDomain. In the case of CellField objects, this specifies that the point coordinates on which we evaluate the cell-local shape basis functions should be provided in the parametric space of the reference cell (to avoid the need to use the inverse of the geometrical map). However, the output from evaluation, as usual in finite elements defined parametrically, is the cell-local shape function in the physical domain evaluated at the corresponding mapped point.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Recall from above that CellField objects are designed to be evaluated at CellPoint objects, and that we extracted a CellPoint object, Qₕ_cell_point, out of a CellQuadrature, of ReferenceDomain trait DomainStyle. Thus, we can evaluate dv and du at the quadrature rule evaluation points, on all cells, straight away as:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_at_Qₕ = evaluate(dv,Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"du_at_Qₕ = evaluate(du,Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"There are a pair of worth noting observations on the result of the previous two instructions. First, both dv_at_Qₕ and du_at_Qₕ are arrays of type Fill (i.e., a constant array that only stores the entry once) because we are using the same quadrature and reference FE for all cells. This (same entry) is justified by: (1) the local shape functions are evaluated at the same set of points in the reference cell parametric space for all cells (i.e., the quadrature rule points), and (2) the shape functions in physical space have these very same values at the corresponding mapped points in the physical space for all cells. Thus they provide the same entry for whatever index we provide.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_at_Qₕ[rand(1:num_cells(Tₕ))]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"du_at_Qₕ[rand(1:num_cells(Tₕ))]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"At this point, the reader may want to observe which object results from the evaluation of, e.g., dv_at_Qₕ, at a different set points for each cell (e.g. by building its own array of arrays of Points).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Going back to our example, any entry of dv_at_Qₕ is a rank-2 array of size 9x4 that provides in position [i,j] the j-th test shape function at the i-th quadrature rule evaluation point. On the other hand, any entry of du_at_Qₕ is a rank-3 array of size 9x1x4 that provides in position [i,1,j] the j-th trial shape function at the i-th quadrature point. The reader might be wondering why the rank of these two arrays are different. The rationale is that, by means of the Julia broadcasting of the * operation on these two arrays, we get the 9x4x4 array where the [i,j,k] entry stores the product of the j-th test and k-th trial functions, both evaluated at the i-th quadrature point. If we sum over the i-index, we obtain part of the data required to compute the cell-local matrix that we assemble into the global matrix in order to get a mass matrix. For those readers more used to traditional finite element codes, the broadcast followed by the sum over i, provides the data required in order to implement the following triple standard for-nested loop:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":" M[:,:]=0.0\n Loop over quadrature points i\n   detJK_wi=det(JK)*w[i]\n   Loop over shape test functions j\n     Loop over shape trial functions k\n        M[j,k]+=shape_test[i,j]*shape_trial[i,k]*detJK_wi","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"where det(JK) represents the determinant of the reference-physical mapping of the current cell, and w[i] the quadrature rule weight corresponding to the i-th evaluation point. Using Julia built-in support for broadcasting, we can vectorize the full operation, and get much higher performance.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The highest-level possible way of performing the aforementioned broadcasted * is by building a \"new\" CellField instance by multiplying the two FEBasis objects, and then evaluating the resulting object at the points in Qₕ_cell_point. This is something common in Gridap. One can create new CellField objects out of existing ones, e.g., by performing operations among them, or by applying a differential operator, such as the gradient.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_mult_du = du*dv","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_mult_du_at_Qₕ = evaluate(dv_mult_du,Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can check that any entry of the resulting Fill array is the 9x4x4 array resulting from the broadcasted * of the two aforementioned arrays. In order to do so, we can use the so-called Broadcasting(*) Gridap Map (one of the cornerstones of Gridap).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"A Map represents a (general) function (a.k.a. map or mapping) that takes elements in its domain and return elements in its range. A Field is a sub-type of Map for the particular domain and ranges of physical fields detailed above. Why do we need to define the Map type in Gridap instead of using the Julia Function? Map is essential for performance, as we will explain later on.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The Map below is a map that broadcasts the * operation. When applied to arrays of numbers, it essentially translates into the built-in Julia broadcast (check that below!). However, as we will see along the tutorial, such a Map can also be applied to, e.g., (cell) arrays of Fields (arrays of Fields, resp.) to build new (cell) arrays of Fields (arrays of Fields, resp.). This becomes extremely useful to build and evaluate discrete variational forms.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"m=Broadcasting(*)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"A=evaluate(m,dv_at_Qₕ[rand(1:num_cells(Tₕ))],du_at_Qₕ[rand(1:num_cells(Tₕ))])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"B=broadcast(*,dv_at_Qₕ[rand(1:num_cells(Tₕ))],du_at_Qₕ[rand(1:num_cells(Tₕ))])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(A .≈ B)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(A .≈ dv_mult_du_at_Qₕ[rand(1:num_cells(Tₕ))])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Recall from above that CellField objects are also CellDatum objects. Thus, one can use the get_data generic function to extract, in an array, the collection of quantities, one per each cell of the triangulation, out of them. As one may expect, in the case of our FEBasis objects dv and du at hand, get_data returns a (cell) array of arrays of Field objects, i.e., the cell-local shape basis functions:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_array = get_data(dv)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"du_array = get_data(du)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(dv_array,AbstractVector{<:AbstractVector{<:Field}})","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(du_array,AbstractVector{<:AbstractArray{<:Field,2}})","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test length(dv_array) == num_cells(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test length(du_array) == num_cells(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As expected, both dv_array and du_array are (conceptually) vectors (i.e, rank-1 arrays) with as many entries as cells. The concrete type of each vector differs, though, i.e., Fill and LazyArray, resp. (We will come back to LazyArrays below, as they play a fundamental role in the way in which the finite element method is implemented in Gridap.) For each cell, we have arrays of Field objects. Recall from above that Map and Field (with Field a subtype of Map), and CellDatum and CellField (with CellField a subtype of CellDatum) and the associated type hierarchies, are fundamental in Gridap for the implementation of variational methods in finite-dimensional spaces. Field conceptually represents a physical (scalar, vector, or tensor) field. Field objects can be evaluated at single Point objects (or at an array of them in one shot), and they return scalars (i.e., a sub-type of Julia Number), VectorValue, or TensorValue objects (or an array of them, resp.)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In order to evaluate a Field object at a Point object, or at an array of Points, we can use the evaluate generic function in its API. For example, the following statement","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕ₃ = dv_array[1][3]\nevaluate(ϕ₃,[Point(0,0),Point(1,0),Point(0,1),Point(1,1)])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"evaluates the 3rd test shape function of the local space of the first cell at the 4 vertices of the cell (recall from above that, for the implementation of Lagrangian finite elements being used in this tutorial, shape functions are thought to be evaluated at point coordinates expressed in the parametric space of the reference cell). As expected, ϕ₃ evaluates to one at the 3rd vertex of the cell, and to zero at the rest of vertices, as ϕ₃ is the shape function associated to the Lagrangian node/ DOF located at the 3rd vertex. We can also evaluate all shape functions of the local space of the first cell (i.e., an array of Fields) at once at an array of Points","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕ = dv_array[1]\nevaluate(ϕ,[Point(0,0),Point(1,0),Point(0,1),Point(1,1)])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As expected, we get the Identity matrix, as the shape functions of the local space have, by definition, the Kronecker delta property.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"However, and here comes one of the main take-aways of this tutorial, in Gridap, (cell-wise) arrays of Fields (or arrays of Fields) are definitely NOT conceived to be evaluated following the approach that we used in the previous examples, i.e., by manually extracting the Field (array of Fields) corresponding to a cell, and then evaluating it (them) at a given set of Points. Instead, one uses the lazy_map generic function, which combined with the evaluate function, represents the operation of walking over all cells, and evaluating the fields, cell by cell, as a whole. This is illustrated in the following piece of code:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"dv_array_at_qₖ = lazy_map(evaluate,dv_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"du_array_at_qₖ = lazy_map(evaluate,du_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note that the results of these two expressions are equivalent to the ones of evaluate(dv, Qₕ_cell_point) and evaluate(du,Qₕ_cell_point), resp. (check it!) In fact, these latter two expressions translate under the hood into the calls to lazy_map above. These calls to lazy_map return an array of the same length of the input arrays, with their i-th entry conceptually defined, e.g., as evaluate(du_array[i],qₖ[i]) in the case of the second array. To be \"conceptually defined as\" does not mean that they are actually computed as evaluate(du_array[i],qₖ[i]). Indeed they don't, this would not be high performant.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"You might now be wondering what the main point behind lazy_map is. lazy_map turns out to be a cornerstone in Gridap. (At this point, you may execute methods(lazy_map) to observe that a large amount of programming logic is devoted to it.) Let us try to answer it more abstractly now. However, this will be revisited along the tutorial with additional examples.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"lazy_map can be applied to a Map and an array or a set of arrays, all with the same layout, that provide at every entry the arguments of the map. It conceptually returns the array that results from applying the Map to the arguments in each index of the argument array(s). Usually, the resulting type is a LazyArray.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"When the resulting LazyArray entries are also Maps, one could evaluate the LazyArray on the array(s) that provide the argument(s) (i.e., its domain) using again a lazy_map. E.g., for the sub-type Field, one can create an array of fields, e.g., cell shape function, apply a Map over this array, e.g., a scaling of the shape functions, using lazy_map. The resulting array (conceptually also an array of Fields) can be evaluated in a set of points applying evaluate using lazy_map, as in the two code lines above.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"These lazy objects are cornerstones of Gridap for the following reasons:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"To keep memory allocation (and consumption) at very low levels, lazy_map NEVER returns an array that stores the result at all cells at once. In the two examples above, this is achieved using Fill arrays. However, this is only possible in very particular scenarios (see discussion above). In more general cases, the array resulting from lazy_map does not have the same entry in all cells. In such cases, lazy_map returns a LazyArray, which is another essential component of Gridap. In a nutshell, a LazyArray is an array that applies entry-wise arrays of Maps (functions, operations) over array(s) that provide the Maps arguments. These operations are only computed when accessing the corresponding index, thus the name lazy. Besides, the entries of these are computed in an efficient way, using a set of mechanisms that will be illustrated below with examples (e.g., using cache to store the entry-wise data without the need to allocate memory each time we access the LazyArray).\nApart from Function objects, such as evaluate, lazy_map can also be used to apply Maps to arguments. For example, Broadcasting(*) presented above. A Map (or its sub-type Field) can be applied via lazy_map to other Maps (or arrays of Maps) to build a new Map (or array of Maps). Thus, the recursive application of lazy_map lets us build complex operation trees among arrays of Maps as the ones required for the implementation of variational forms. While building these trees, by virtue of Julia support for multiple type dispatching, there are plenty of opportunities for optimization by changing the order in which the operations are performed. These optimizations typically come in the form of a significant saving of FLOPs by exploiting the particular properties of the Maps at hand, but could also come from higher granularity for vectorized array operations when the expressions are actually evaluated. Indeed, the arrays that one usually obtains from lazy_map differ in some cases from the trivial LazyArrays that one would expect from a naive combination of the arguments to lazy_map\nUsing lazy_map we are hiding thousands of cell loops across the code (as the one for the computation of the element matrices above). As a result, Gridap is much more expressive for cell-wise implementations.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Exploring-another-type-of-CellField-objects-1","page":"13 Low-level API Poisson equation","title":"Exploring another type of CellField objects","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us now work with another type of CellField objects, the ones that are used to represent an arbitrary element of a global FE space of functions, i.e., a FE function. A global FE function can be understood conceptually as a collection of Fields, one per each cell of the triangulation. The Field corresponding to a cell represents the restriction of the global FE function to the cell. (Recall that in finite elements, global functions are defined piece-wise on each cell.) As we did in the previous section, we will explore, at different levels, how FE functions are evaluated. However, we will dig deeper into this by illustrating some of the aforementioned mechanisms on which LazyArray relies in order to efficiently implement the entry-wise application of an operation (or array of operations) to a set of input arrays.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us now build a FE function belonging to the global trial space of functions Uₕ, with rand free DOF values. Using Gridap higher-level API, this can be achieved as follows","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ = FEFunction(Uₕ,rand(num_free_dofs(Uₕ)))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As expected from the discussion above, the returned object is a CellField object:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(uₕ,CellField)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Thus, we can, e.g., query the value of its DomainStyle trait, that turns out to be ReferenceDomain","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(uₕ) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Thus, in order to evaluate the Field object that represents the restriction of the FE function to a given cell, we have to provide Points in the parametric space of the reference cell, and we get the value of the FE function at the corresponding mapped Points in the physical domain. This should not come as a surprise as we have that: (1) the restriction of the FE function to a given cell is mathematically defined as a linear combination of the local shape functions of the cell (with coefficients given by the values of the DOFs at the cell). (2) As observed in the previous section, the shape functions are such that their value at Points that are mapped from the reference cell to the physical cell by the cell geometrical map can be simply be obtained by evaluating the corresponding shape function in the reference FE at the same Points in the parametric space (without the need to compute the geometrical map and its inverse, i.e., exploiting the fact that the combination of this two is the identity map). This property is thus transferred to the FE function.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As FE functions are CellField objects, we can evaluate them at CellPoint objects. Let us do it at the points within Qₕ_cell_point (see above for a justification of why this is possible):","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_at_Qₕ = evaluate(uₕ,Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note that internally this is just the application of evaluate via lazy_map for the raw (i.e., without the CellDatum metadata) cell arrays of uₕ and Qₕ_cell_point (obtained via get_data). Internally, a change_domain is invoked if required, i.e., the two CellDatum do not have the same DomainStyle trait value (not the case here). You can check it by getting into this call using the VSCode debugger (write @enter at the beginning of the line and run it). In any case, we provide many more details below.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"For the first time in this tutorial, we have obtained a cell array of type LazyArray from evaluating a CellField at a CellPoint.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(uₕ_at_Qₕ,LazyArray)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This makes sense as a finite element function restricted to a cell is, in general, different in each cell, i.e., it evaluates to different values at the quadrature rule evaluation points. In other words, the Fill array optimization that was performed for the evaluation of the cell-wise local shape functions dv and du does not apply here, and a LazyArray has to be used instead.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Although it is hard to understand the full concrete type name of uₕ_at_Qₕ at this time","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"print(typeof(uₕ_at_Qₕ))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"we will dissect LazyArrays in this section up to an extent that will allow us to have a better grasp of it. By now, the most important thing for you to keep in mind is that LazyArrays objects encode a recipe to produce its entries just-in-time when they are accessed. They NEVER store all of its entries at once. Even if the expression uₕ_at_Qₕ typed in the REPL, (or inline evaluations in your code editor) show the array with all of its entries at once, don't get confused. This is because the Julia REPL is evaluating the array at all indices and collecting the result just for printing purposes.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Just as we did with FEBasis, we can extract an array of Field objects out of uₕ_at_Qₕ, as uₕ_at_Qₕ is also a CellBasis object.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_array = get_data(uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As expected, uₕ_array is (conceptually) a vector (i.e., rank-1 array) of Field objects.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(uₕ_array,AbstractVector{<:Field})","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Its concrete type is, though, LazyArray","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(uₕ_array,Gridap.Fields.LazyArray)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"with full name, as above, of a certain complexity (to say the least):","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"print(typeof(uₕ_array))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As mentioned above, lazy_map returns LazyArrays in the most general scenarios. Thus, it is reasonable to think that get_data(uₕ) returns an array that has been built via lazy_map. (We advance now that this is indeed the case.) On the other hand, as uₕ_array is (conceptually) a vector (i.e., rank-1 array) of Field objects, this also tells us that the lazy_map/LazyArray pair does not only play a fundamental role in the evaluation of (e.g., cell) arrays of Fields on (e.g., cell) arrays of arrays of Points, but also in building new cell arrays of Fields (i.e., the local restriction of a FE function to each cell) out of existing ones (i.e., the cell array with the local shape functions). In the words of the previous section, we can use lazy_map to build complex operation trees among arrays of Fields, as required by the computer implementation of variational methods.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The key question now is: what is the point behind get_data(uₕ) returning a LazyArray of Fields, and not just a plain Julia array of Fields? At the end of the day, Field objects themselves have very low memory demands, they only need to hold the necessary information to encode their action (evaluation) on a Point/array of Points. This is in contrast to the evaluation of (e.g., cell) arrays of Fields (or arrays of Fields) at an array of Points, which does consume a significantly allocation of memory (if all entries are to be stored at once in memory, and not by demand). The short answer is higher performance. Using LazyArrays to encode operation trees among cell arrays of Fields, we can apply optimizations when evaluating these operation trees that would not be possible if we just computed a plain array of Fields. If all this sounds quite abstract, (most probably it does), we are going to dig into this further in the rest of the section.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As mentioned above, uₕ_array can be conceptually seen as an array of Fields. Thus, if we access to a particular entry of it, we should get a Field object. (Although possible, this is not the way in which uₕ_array is conceived to be used, as was also mentioned in the previous section.) This is indeed confirmed when accessing, e.g., the third entry of uₕ_array:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ³ = uₕ_array[3]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(uₕ³,Field)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The concrete type of uₕ³ is LinearCombinationField. This type represents a Field defined as a linear combination of an existing vector of Fields. This sort of Fields can be built using the linear_combination generic function. Among its methods, there is one which takes (1) a vector of scalars (i.e., Julia Numbers) with the coefficients of the expansion and (2) a vector of Fields as its two arguments, and returns a LinearCombinationField object. As mentioned above, this is the exact mathematical definition of a FE function restricted to a cell.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us manually build uₕ³. In order to do so, we can first use the get_cell_dof_values generic function, which extracts out of uₕ a cell array of arrays with the DOF values of uₕ restricted to all cells of the triangulation (defined from a conceptual point of view).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Uₖ = get_cell_dof_values(uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"(The returned array turns to be of concrete type LazyArray, again to keep memory allocation low, but let us skip this detail for the moment.) If we restrict Uₖ and dv_array to the third cell","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Uₖ³ = Uₖ[3]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕₖ³ = dv_array[3]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"we get the two arguments that we need to invoke linear_combination in order to build our manually built version of uₕ³","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"manual_uₕ³ = linear_combination(Uₖ³,ϕₖ³)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can double-check that uₕ³ and manual_uₕ³ are equivalent by evaluating them at the quadrature rule evaluation points, and comparing the result:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test evaluate(uₕ³,qₖ[3]) ≈ evaluate(manual_uₕ³,qₖ[3])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Following this idea, we can go even further and manually build a plain Julia vector of LinearCombinationField objects as follows:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"manual_uₕ_array = [linear_combination(Uₖ[i],dv_array[i]) for i=1:num_cells(Tₕ)]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"And we can (lazily) evaluate this manually-built array of Fields at a cell array of arrays of Points (i.e., at qₖ) using lazy_map:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"manual_uₕ_array_at_qₖ = lazy_map(evaluate,manual_uₕ_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The entries of the resulting array are equivalent to those of the array that we obtained from Gridap automatically, i.e., uₕ_at_Qₕ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all( uₕ_at_Qₕ .≈ manual_uₕ_array_at_qₖ )","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"However, and here it comes the key of the discussion, the concrete types of uₕ_at_Qₕ and manual_uₕ_array_at_qₖ do not match.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test typeof(uₕ_at_Qₕ) != typeof(manual_uₕ_array_at_qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This is because evaluate(uₕ,Qₕ_cell_point) does not follow the (naive) approach that we followed to build manual_uₕ_array_at_qₖ, but it instead calls lazy_map under the hood as follows","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_array_at_qₖ = lazy_map(evaluate,uₕ_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now we can see that the types of uₕ_array_at_qₖ and uₕ_at_Qₕ match:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test typeof(uₕ_array_at_qₖ) == typeof(uₕ_at_Qₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Therefore, why Gridap does not build manual_uₕ_array_at_qₖ? what's wrong with it? Let us first try to answer this quantitatively. Let us assume that we want to sum all entries of a LazyArray. In the case of LazyArrays of arrays, this operation is only well-defined if the size of the arrays of all entries matches. This is the case of the uₕ_array_at_qₖ and manual_uₕ_array_at_qₖ arrays, as we have the same quadrature rule at all cells. We can write this function following the Gridap internals' way.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"function smart_sum(a::LazyArray)\n  cache=array_cache(a)             #Create cache out of a\n  sum=copy(getindex!(cache,a,1))   #We have to copy the output\n                                   #from get_index! to avoid array aliasing\n  for i in 2:length(a)\n    ai = getindex!(cache,a,i)      #Compute the i-th entry of a\n                                   #re-using work arrays in cache\n    sum .= sum .+ ai\n  end\n  sum\nend","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The function uses the so-called \"cache\" of a LazyArray. In a nutshell, this cache can be thought as a place-holder of work arrays that can be re-used among different evaluations of the entries of the LazyArray (e.g., the work array in which the result of the computation of an entry of the array is stored.) This way, the code is more performant, as the cache avoids that these work arrays are created repeatedly when traversing the LazyArray and computing its entries. It turns out that LazyArrays are not the only objects in Gridap that (can) work with caches. Map and Field objects also provide caches for reusing temporary storage among their repeated evaluation on different arguments of the same types. (For the eager reader, the cache can be obtained out of a Map/Field with the return_cache abstract method; see also return_type, return_value, and evaluate! functions of the abstract API of Maps). When a LazyArray is created out of objects that in turn rely on caches (e.g., a LazyArray with entries defined as the entry-wise application of a Map to two LazyArrays), the caches of the latter objects are also handled by the former object, so that this scheme naturally accommodates top-down recursion, as per-required in the evaluation of complex operation trees among arrays of Fields, and their evaluation at a set of Points. We warn the reader this is a quite complex mechanism. The reader is encouraged to follow with a debugger, step by step, the execution of the smart_sum function with the LazyArrays built above in order to gain some familiarity with this mechanism.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"If we @time the smart_sum function with uₕ_array_at_qₖ and manual_uₕ_array_at_qₖ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"smart_sum(uₕ_array_at_qₖ)        # Execute once before to neglect JIT-compilation time\nsmart_sum(manual_uₕ_array_at_qₖ) # Execute once before to neglect JIT-compilation time","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@time begin\n        for i in 1:100_000\n         smart_sum(uₕ_array_at_qₖ)\n        end\n      end","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@time begin\n        for i in 1:100_000\n          smart_sum(manual_uₕ_array_at_qₖ)\n        end\n      end","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"we can observe that the array returned by Gridap can be summed in significantly less time, using significantly less allocations.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us try to answer the question now qualitatively. In order to do so, we can take a look at the structure of both LazyArrays using the print_op_tree function provided by Gridap","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"print_op_tree(uₕ_array_at_qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"print_op_tree(manual_uₕ_array_at_qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can observe from the output of these calls the following:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_array_at_qₖ is a LazyArray whose entries are defined as the result of applying a Fill array of LinearCombinationMap{Colon} Maps to a LazyArray and a Fill array. The first array provides the FE function DOF values restricted to each cell, and the second the local basis shape functions evaluated at the quadrature points. As the shape functions in physical space have the same values in all cells at the corresponding mapped points in physical space, there is no need to re-evaluate them at each cell, we can evaluate them only once. And this is what the second Fill array stores as its unique entry, i.e., a matrix M[i,j] defined as the value of the j-th Field (i.e., shape function) evaluated at the i-th Point. This is indeed the main optimization that lazy_map applies compared to our manual construction of uₕ_array_at_qₖ. It is worth noting that, if v denotes the linear combination coefficients, and M the matrix resulting from the evaluation of an array of Fields at a set of Points, with M[i,j] being the value of the j-th Field evaluated at the i-th point, the evaluation of LinearCombinationMap{Colon} at v and M returns a vector w with w[i] defined as w[i]=sum_k v[k]*M[i,k], i.e., the FE function evaluated at the i-th point. uₕ_array_at_qₖ handles the cache of LinearCombinationMap{Colon} (which holds internal storage for w) and that of the first LazyArray, so that when it retrieves the DOF values v of a given cell, and then applies LinearCombinationMap{Colon} to v and M, it does not have to allocate any temporary working arrays, but re-uses the ones stored in the different caches.\nmanual_uₕ_array_at_qₖ is also a LazyArray, but structured rather differently to uₕ_array_at_qₖ. In particular, its entries are defined as the result of applying a plain array of LinearCombinationFields to a Fill array of Points that holds the coordinates of the quadrature rule evaluation points in the parametric space of the reference cell (which are equivalent for all cells, thus the Fill array). The evaluation of a LinearCombinationField on a set of Points ultimately depends on LinearCombinationMap. As seen in the previous point, the evaluation of this Map requires a vector v and a matrix M. v was built in-situ when building each LinearCombinationField, and stored within these instances. However, in contrast to uₕ_array_at_qₖ, M is not part of manual_uₕ_array_at_qₖ, and thus it has to be (re-)computed each time that we evaluate a new LinearCombinationField instance on a set of points. This is the main source of difference on the computation times observed. By eagerly constructing our array of LinearCombinationFields instead of deferring it until (lazy) evaluation via lazy_map, we lost optimization opportunities. We stress that manual_uₕ_array_at_qₖ also handles the cache of LinearCombinationField (that in turn handles the one of LinearCombinationMap), so that we do not need to allocate M at each cell, we re-use the space within the cache of LinearCombinationField.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"To conclude the section, we expect the reader to be convinced of the negative consequences in performance that an eager (early) evaluation of the entries of the array returned by a lazy_map call can have in performance. The leitmotif of Gridap is laziness. When building new arrays of Fields (or arrays of Fields), out of existing ones, or when evaluating them at a set of Points, ALWAYS use lazy_map. This may expand across several recursion levels when building complex operation trees among arrays of Fields. The more we defer the actual computation of the entries of LazyArrays, the more optimizations will be available at the Gridap's disposal by re-arranging the order of operations via exploitation of the particular properties of the arrays at hand. And this is indeed what we are going to do in the rest of the tutorial, namely calling lazy_map to build new cell arrays out of existing ones, to end in a lazy cell array whose entries are the cell matrices and cell vectors contributions to the global linear system.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us, e.g., build Uₖ manually using this idea. First, we extract out of uₕ and Uₕ two arrays with the free and fixed (due to strong Dirichlet boundary conditions) DOF values of uₕ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_free_dof_values = get_free_dof_values(uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₕ_dirichlet_dof_values = get_dirichlet_dof_values(Uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"So far these are plain arrays, nothing is lazy. Then we extract out of Uₕ the global indices of the DOFs in each cell, the well-known local-to-global map in FE methods.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"σₖ = get_cell_dof_ids(Uₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Finally, we call lazy_map to build a LazyArray, whose entries, when computed, contain the global FE function DOFs restricted to each cell.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"m = Broadcasting(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"manual_Uₖ = lazy_map(m,σₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"PosNegReindex is a Map that is built out of two vectors. We evaluate it at indices of array entries. When we give it a positive index, it returns the entry of the first vector corresponding to this index, and when we give it a negative index, it returns the entry of the second vector corresponding to the flipped-sign index. We can check this with the following expressions","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test evaluate(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values),3) == uₕ_free_dof_values[3]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test evaluate(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values),-7) == uₕ_dirichlet_dof_values[7]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The Broadcasting(op) Map lets us, in this particular example, broadcast the PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values) Map to an array a global DOF ids, to obtain the corresponding cell DOF values. As regular, Broadcasting(op) provides a cache with the work array required to store its result. LazyArray uses this cache to reduce the number of allocations while computing its entries just-in-time. Please note that in Gridap we put negative labels to fixed DOFs and positive to free DOFs in σₖ, thus we use an array that combines σₖ with the two arrays of free and fixed DOF values accessing the right one depending on the index. But everything is lazy, only computed when accessing the array. As mentioned multiple times, laziness is one f the leitmotifs in Gridap, the other being immutability.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Immutability is a feature that comes from functional programming. An immutable object cannot be modified after created. Since objects cannot change, one does not require to track how they change, i.e., there is no need to design (and understand) state diagrams. A code that strictly sticks to this principle is much more readable. Due to laziness, Gridap objects are light-weight, and the (lazy) modification of existing (lazy) objects is highly efficient. You can find this action many times in the code above, in which we use lazy_map to perform actions over lazy objects (e.g., LazyArray or Fill arrays) to create new lazy objects. However, strictly conforming to immutability can be inefficient in some very specific scenarios. Gridap departs from immutability in the linear algebra part, since we want to re-use the memory allocation as much as possible for global arrays or symbolic/numeric factorisations in linear solvers.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#The-geometrical-model-1","page":"13 Low-level API Poisson equation","title":"The geometrical model","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"From the triangulation we can also extract the cell map, i.e., the geometrical map that takes points in the parametric space 01^D (the SEGMENT, QUAD, or HEX in 1, 2, or 3D, resp.) and maps it to the cell in the physical space Omega.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ξₖ = get_cell_map(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note that this map is just a LazyArray of Fields. The metadata related to CellField is not required here, the cell map can only go from the reference to physical space, and its domain can only be a reference cell. For this reason, it is not a CellField.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The cell map takes at each cell points in the parametric space and returns the mapped points in the physical space. Even though this space does not need a global definition (nothing has to be solved here), it is continuous across interior faces.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As usual, this cell_map is a LazyArray. At each cell, it provides the Field that maps Points in the parametric space of the reference cell to Points in physical space.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The node coordinates can be extracted from the triangulation, returning a global array of Points. You can see that such array is stored using Cartesian indices instead of linear indices. It is more natural for Cartesian meshes.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"X = get_node_coordinates(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"You can also extract a cell-wise array that provides the node indices per cell","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"cell_node_ids = get_cell_node_ids(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"or the cell-wise nodal coordinates, combining the previous two arrays","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"_Xₖ = get_cell_coordinates(Tₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#A-low-level-definition-of-the-cell-map-1","page":"13 Low-level API Poisson equation","title":"A low-level definition of the cell map","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now, let us create the geometrical map almost from scratch, using the concepts that we have learned so far. In this example, we consider that the geometry is represented with a bilinear map, and we thus use a first-order, scalar-valued FE space to represent the nodal coordinate values. To this end, as we did before with the global space of FE functions, we first need to create a Polytope using an array of dimension D with the parameter HEX_AXIS. Then, this is used to create the scalar first order Lagrangian reference FE.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"pol = Polytope(Fill(HEX_AXIS,D)...)\nreffe_g = LagrangianRefFE(Float64,pol,1)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Next, we extract the basis of shape functions out of this Reference FE, which is a set of Fields, as many as shape functions. We note that these Fields have as domain the parametric space 01^D. Thus, they can readily be evaluated for points in the parametric space.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕrg = get_shapefuns(reffe_g)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now, we create a global cell array that has the same reference FE basis for all cells.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕrgₖ = Fill(ϕrg,num_cells(Tₕ))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Next, we use lazy_map to build a LazyArray that provides the coordinates of the nodes of each cell in physical space. To this end, we use the Broadcasting(Reindex(X)) and apply it to cell_node_ids.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Xₖ = lazy_map(Broadcasting(Reindex(X)),cell_node_ids)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Reindex is a Map that is built out of a single vector, X in this case. We evaluate it at indices of array entries, and it just returns the entry of the vector from which it is built corresponding to this index. We can check this with the following expressions:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test evaluate(Reindex(X),3) == X[3]","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"If we combine Broadcasting and Reindex, then we can evaluate efficiently the Reindex Map at arrays of node ids, i.e., at each of the entries of cell_node_ids. lazy_map is used for reasons hopefully clear at this point (low memory consumption, efficient computation of the entries via caches, further opportunities for optimizations when combined with other lazy_map calls, etc.). Finally, we can check that Xₖ is equivalent to the array returned by Gridap, i.e, _Xₖ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test Xₖ == _Xₖ == get_cell_coordinates(Tₕ) # check","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Next, we can compute the geometrical map as the linear combination of these shape functions in the parametric space with the node coordinates (at each cell)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ψₖ = lazy_map(linear_combination,Xₖ,ϕrgₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This is the mathematical definition of the geometrical map in FEs! (see above for a description of the linear_combination generic function). As expected, the FE map that we have built manually is equivalent to the one internally built by Gridap.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test lazy_map(evaluate,ψₖ,qₖ) == lazy_map(evaluate,ξₖ,qₖ) # check","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"It is good to stress (if it was not fully grasped yet) that lazy_map(k,a,b), with k being a callable Julia object, is semantically (conceptually) equivalent to map(k,a,b) but, among others, with a lazy result instead of a plain Julia array. A Julia object is callable if it makes sense to pass arguments to it. For example, objects k such that isa(k,Map)==true are callable.  For these objects, k(x...) is equivalent to evaluate(k,x...).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Following the same ideas, we can compute the Jacobian of the geometrical map (cell-wise). The Jacobian of the transformation is simply its gradient. The gradient in the parametric space can be built using two equivalent approaches. On the one hand, we can apply the Broadcasting(∇) Map to the array of Fields with the local shape basis functions (i.e., ϕrg). This results in an array of Fields with the gradients, (Recall that Maps can be applied to array of Fields in order to get new array of Fields) that we use to build a Fill array with the result. Finally, we build the lazy array with the cell-wise Jacobians of the map as the linear combination of the node coordinates and the gradients of the local cell shape basis functions:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇ϕrg  = Broadcasting(∇)(ϕrg)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇ϕrgₖ = Fill(∇ϕrg,num_cells(model))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"J = lazy_map(linear_combination,Xₖ,∇ϕrgₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note that lazy_map is not required in the first expression, as we are not actually working with cell arrays. On the other hand, using lazy_map, we can apply Broadcasting(∇) to the cell array of Fields with the geometrical map.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"lazy_map(Broadcasting(∇),ψₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As mentioned above, those two approaches are equivalent","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test typeof(J) == typeof(lazy_map(Broadcasting(∇),ψₖ))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test lazy_map(evaluate,J,qₖ) == lazy_map(evaluate,lazy_map(Broadcasting(∇),ψₖ),qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Computing-the-gradients-of-the-trial-and-test-FE-space-bases-1","page":"13 Low-level API Poisson equation","title":"Computing the gradients of the trial and test FE space bases","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Another salient feature of Gridap is that we can directly take the gradient of finite element bases. (In general, of any CellField object.) In the following code snippet, we do so for dv and du","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"grad_dv = ∇(dv)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"grad_du = ∇(du)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The result of this operation when applied to a FEBasis object is a new FEBasis object.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(grad_dv, Gridap.FESpaces.FEBasis)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test isa(grad_du, Gridap.FESpaces.FEBasis)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can also extract an array of arrays of Fields, as we have done before with FEBasis objects.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"grad_dv_array = get_data(grad_dv)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"grad_du_array = get_data(grad_du)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The resulting LazyArrays encode the so-called pull back transformation of the gradients. We need this transformation in order to compute the gradients in physical space. The gradients in physical space are indeed the ones that we need to integrate in the finite element method, not the reference ones, even if we always evaluate the integrals in the parametric space of the reference cell. We can also check that the DomainStyle trait of grad_dv and grad_du is ReferenceDomain","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(grad_dv) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test DomainStyle(grad_du) == ReferenceDomain()","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This should not come as a surprise, as this is indeed the nature of the pull back transformation of the gradients. We provide Points in the parametric space of the reference cell, and we get back the gradients in physical space evaluated at the mapped Points in physical space.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We can manually build grad_dv_array and grad_du_array as follows","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕr                   = get_shapefuns(reffe)\n∇ϕr                  = Broadcasting(∇)(ϕr)\n∇ϕrₖ                 = Fill(∇ϕr,num_cells(Tₕ))\nmanual_grad_dv_array = lazy_map(Broadcasting(push_∇),∇ϕrₖ,ξₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇ϕrᵀ                 = Broadcasting(∇)(transpose(ϕr))\n∇ϕrₖᵀ                = Fill(∇ϕrᵀ,num_cells(Tₕ))\nmanual_grad_du_array = lazy_map(Broadcasting(push_∇),∇ϕrₖᵀ,ξₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We note the use of the Broadcasting(push_∇) Map at the last step. For Lagrangian FE spaces, this Map represents the pull back of the gradients. This transformation requires the gradients of the shape functions in the reference space, and the (gradient of the) geometrical map. The last step, e.g., the construction of manual_grad_dv_array, actually translates into the combination of the following calls to lazy_map to build the final transformation:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Build array of Fields with the Jacobian transposed at each cell","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Jt     = lazy_map(Broadcasting(∇),ξₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Build array of Fields with the inverse of the Jacobian transposed at each cell","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"inv_Jt = lazy_map(Operation(inv),Jt)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Build array of arrays of Fields defined as the broadcasted single contraction of the Jacobian inverse transposed and the gradients of the shape functions in the reference space","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"low_level_manual_gradient_dv_array = lazy_map(Broadcasting(Operation(⋅)),inv_Jt,∇ϕrₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"As always, we check that all arrays built are are equivalent","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test typeof(grad_dv_array) == typeof(manual_grad_dv_array)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test lazy_map(evaluate,grad_dv_array,qₖ) == lazy_map(evaluate,manual_grad_dv_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test lazy_map(evaluate,grad_dv_array,qₖ) == lazy_map(evaluate,low_level_manual_gradient_dv_array,qₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test lazy_map(evaluate,grad_dv_array,qₖ) == evaluate(grad_dv,Qₕ_cell_point)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"With the lessons learned so far in this section, it is left as an exercise for the reader to manually build the array that get_data returns when we call it with the CellField object resulting from taking the gradient of uₕ as an argument, i.e., get_data(∇(uₕ)).","category":"page"},{"location":"pages/t013_poisson_dev_fe/#A-low-level-implementation-of-the-residual-integration-and-assembly-1","page":"13 Low-level API Poisson equation","title":"A low-level implementation of the residual integration and assembly","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In the rest of the tutorial we aim to solve a Poisson equation with homogeneous source term, i.e., f=0 and non-homogeneous Dirichlet boundary conditions u=g_0 on Gamma_D, with  Gamma_D being the whole boundary of the model. While the strong imposition of non-homogeneous Dirichlet boundary conditions in Gridap is done under the hood by modifying the global assembly process by subtracting the contributions of boundary conditions from the right hand side of the linear system, in this tutorial, for simplicity, we follow a different approach. This approach requires: (1) to be able to assemble the residual of the PDE for an arbitrary finite element function hatu_h (current section); (2) to be able to assemble the coefficient matrix of the finite element linear system (next section). We briefly outline this solution approach in the sequel.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The discretized variational form of the Poisson problem reads as:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Find u_h in V_h^Gamma_D=v_h in V_hv_h=g^h_0  on  Gamma_D such thata(u_hv_h)=l(v_h)quad forall v_h in V_h^0where V_h^0=v_h in V_hv_h=0  on  Gamma_D and g^h_0 is the interpolation of g_0 on the Dirichlet boundary.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"If we take an arbitrary function hatu_h in V_h^Gamma_D, and compute w_h in V_h^0 as the solution of the following discrete variational problem:","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"a(w_hv_h)=a(hatu_hv_h)-l(v_h)quad forall v_hw_h in V_h^0","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"then, it is easy to see that mathbf u_h=hatu_h-w_h . This is the strategy that we implement in the sequel. Note that, in previous section, we created a FE function using rand for initializing the values of the degrees of freedom. This function indeed plays the role of hatu_h.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us now create manually an array of Fields uₖ that returns the FE function uₕ at each cell, and another array with its gradients, ∇uₖ. We hope that the next set of instructions can be already understood with the material covered so far","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"ϕrₖ = Fill(ϕr,num_cells(Tₕ))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇ϕₖ = manual_grad_dv_array","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"uₖ  = lazy_map(linear_combination,Uₖ,ϕrₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇uₖ = lazy_map(linear_combination,Uₖ,∇ϕₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Let us consider now the integration of (bi)linear forms. The idea is to compute first the following residual for our random function uₕ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"intg = ∇(uₕ)⋅∇(dv)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"but we are going to do it using low-level methods instead.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"First, we create an array that for each cell returns the dot product of the gradients","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Iₖ = lazy_map(Broadcasting(Operation(⋅)),∇uₖ,∇ϕₖ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This array is equivalent to the one within the intg CellField object","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(lazy_map(evaluate,Iₖ,qₖ) .≈ lazy_map(evaluate,get_data(intg),qₖ))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now, we can finally compute the cell-wise residual array, which using the high-level integrate function is","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"res = integrate(∇(uₕ)⋅∇(dv),Qₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"In a low-level, what we do is to apply (create a LazyArray) the IntegrationMap Map over the integrand evaluated at the integration points, the quadrature rule weights, and the Jacobian evaluated at the integration points","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Jq = lazy_map(evaluate,J,qₖ)\nintq = lazy_map(evaluate,Iₖ,qₖ)\niwq = lazy_map(IntegrationMap(),intq,Qₕ.cell_weight,Jq)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(res .≈ iwq)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"The result is the cell-wise residual (previous to assembly). This is a lazy array but you could collect the element residuals into a plain Julia array if you want","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"collect(iwq)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Alternatively, we can use the following syntactic sugar","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"cellvals = ∫( ∇(dv)⋅∇(uₕ) )*Qₕ","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"and check that we get the same cell-wise residual as the one defined above","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(cellvals .≈ iwq)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#Assembling-a-residual-1","page":"13 Low-level API Poisson equation","title":"Assembling a residual","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now, we need to assemble these cell-wise (lazy) residual contributions in a global (non-lazy) array. With all this, we can assemble our vector using the cell-wise residual contributions and the assembler. Let us create a standard assembler struct for the finite element spaces at hand. This will create a vector of size global number of DOFs, and a SparseMatrixCSC, to which we can add contributions.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"assem = SparseMatrixAssembler(Uₕ,Vₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"We create a tuple with 1-entry arrays with the cell vectors (i.e., iwq) and cell-wise global DOF identifiers (i.e., σₖ). If we had additional terms, we would have more entries in the array. You can take a look at the SparseMatrixAssembler struct for more details.","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"rs = ([iwq],[σₖ])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"b = allocate_vector(assem,rs)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"assemble_vector!(b,assem,rs)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#A-low-level-implementation-of-the-Jacobian-integration-and-assembly-1","page":"13 Low-level API Poisson equation","title":"A low-level implementation of the Jacobian integration and assembly","text":"","category":"section"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"After computing the residual, we use similar ideas for the Jacobian. The process is the same as above, so it does not require additional explanations","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"∇ϕₖᵀ = manual_grad_du_array\nint = lazy_map(Broadcasting(Operation(⋅)),∇ϕₖ,∇ϕₖᵀ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test all(collect(lazy_map(evaluate,int,qₖ)) .==\n            collect(lazy_map(evaluate,get_data(∇(du)⋅∇(dv)),qₖ)))","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"intq = lazy_map(evaluate,int,qₖ)\nJq = lazy_map(evaluate,J,qₖ)\niwq = lazy_map(IntegrationMap(),intq,Qₕ.cell_weight,Jq)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"jac = integrate(∇(dv)⋅∇(du),Qₕ)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test collect(iwq) == collect(jac)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"rs = ([iwq],[σₖ],[σₖ])","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"A = allocate_matrix(assem,rs)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"A = assemble_matrix!(A,assem,rs)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"Now we can obtain the free DOFs by subtracting the solution from the initial guess","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"x = A \\ b\nuf = get_free_dof_values(uₕ) - x\nufₕ = FEFunction(Uₕ,uf)","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test sum(integrate((u-ufₕ)*(u-ufₕ),Qₕ)) <= 10^-8","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"or if you like Unicode symbols","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"@test ∑(∫(((u-ufₕ)*(u-ufₕ)))Qₕ) <= 10^-8","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"","category":"page"},{"location":"pages/t013_poisson_dev_fe/#","page":"13 Low-level API Poisson equation","title":"13 Low-level API Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/dg_discretization.jl\"","category":"page"},{"location":"pages/t006_dg_discretization/#Tutorial-6:-Poisson-equation-(with-DG)-1","page":"6 Poisson equation (with DG)","title":"Tutorial 6: Poisson equation (with DG)","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"How to solve a simple PDE with a DG method\nHow to compute jumps and averages of quantities on the mesh skeleton\nHow to implement the method of manufactured solutions\nHow to integrate error norms\nHow to generate Cartesian meshes in arbitrary dimensions","category":"page"},{"location":"pages/t006_dg_discretization/#Problem-statement-1","page":"6 Poisson equation (with DG)","title":"Problem statement","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The goal of this tutorial is to solve a PDE using a Discontinuous Galerkin (DG) formulation. For simplicity, we take the Poisson equation on the unit cube Omega doteq (01)^3 as the model problem, namely","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma doteq partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"where f is the source term and g is the prescribed Dirichlet boundary function. In this tutorial, we follow the method of manufactured solutions since we want to illustrate how to compute discretization errors. We take u(x) = 3 x_1 + x_2^2 + 2 x_3^3 + x_1 x_2 x_3  as the exact solution of the problem for which f(x)= -2 - 12x_3  and g(x) = u(x). The selected manufactured solution u is a third order multi-va riate polynomial, which can be represented exactly by the FE discretization that we are going to define below. In this scenario, the discretization error has to be close to the machine precision. We will use this result to validate the proposed implementation.","category":"page"},{"location":"pages/t006_dg_discretization/#Numerical-Scheme-1","page":"6 Poisson equation (with DG)","title":"Numerical Scheme","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We consider a DG formulation to approximate the problem. In particular, we consider the symmetric interior penalty method (see, e.g. [1], for specific details). For this formulation, the approximation space is made of discontinuous piece-wise polynomials, namely","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"V doteq  vin L^2(Omega) v_Tin Q_p(T) text for all  TinmathcalT  ","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"where mathcalT is the set of all cells T of the FE mesh, and Q_p(T) is a polynomial space of degree p defined on a generic cell T. For simplicity, we consider Cartesian meshes in this tutorial. In this case, the space Q_p(T) is made of multi-variate polynomials up to degree p in each spatial coordinate.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In order to write the weak form of the problem, we need to introduce some notation. The sets of interior and boundary facets associated with the FE mesh mathcalT are denoted here as mathcalF_Lambda and mathcalF_Gamma respectively. In addition, for a given function vin V restricted to the interior facets mathcalF_Lambda, we introduce the well known jump and mean value operators,","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\nlbracklbrack v n rbrackrbrack doteq v^+ n^+ + v^- n^-\n nabla v  doteq dfrac nabla v^+ + nabla v^-2\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"with v^+, and v^- being the restrictions of vin V to the cells T^+, T^- that share a generic interior facet in mathcalF_Lambda, and n^+, and n^- are the facet outward unit normals from either the perspective of T^+ and T^- respectively.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"With this notation, the weak form associated with the interior penalty formulation of our problem reads: find uin V such that a(uv) = l(v) for all vin V. The bilinear and linear forms a(cdotcdot) and l(cdot) have contributions associated with the bulk of Omega, the boundary facets mathcalF_Gamma, and the interior facets mathcalF_Lambda, namely","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na(uv) = a_Omega(uv) + a_Gamma(uv) + a_Lambda(uv)\nl(v) = l_Omega(v) + l_Gamma(v)\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"These contributions are defined as","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na_Omega(uv) doteq sum_TinmathcalT int_T nabla v cdot nabla u  rm dT\n\nl_Omega(v) doteq int_Omega v f  rm dOmega\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the volume,","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na_Gamma(uv)\n   doteq\n    - sum_FinmathcalF_Gamma int_F v (nabla u cdot n)   rm dF\n  - sum_FinmathcalF_Gamma int_F (nabla v cdot n) u   rm dF\n  + sum_FinmathcalF_Gamma dfracgammaF int_F v u  rm dF\n\nl_Gamma(v)\ndoteq\n    - sum_FinmathcalF_Gamma int_F (nabla v cdot n) g   rm dF\n  + sum_FinmathcalF_Gamma dfracgammaF int_F v g  rm dF\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the boundary facets and,","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na_Lambda(uv)\ndoteq\n    - sum_FinmathcalF_Lambda int_F lbracklbrack v n rbrackrbrackcdot  nabla u   rm dF\n  - sum_FinmathcalF_Lambda int_F  nabla v cdot lbracklbrack u n rbrackrbrack  rm dF\n  + sum_FinmathcalF_Lambda dfracgammaF int_F lbracklbrack v n rbrackrbrackcdot lbracklbrack u n rbrackrbrack  rm dF\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the interior facets. In previous expressions, F denotes the diameter  of the face F (in our Cartesian grid, this is equivalent to the  characteristic mesh size h), and gamma is a stabilization parameter that  should be chosen large enough such that the bilinear form a(cdotcdot) is  stable and continuous. Here, we take gamma = p (p+1) as done in the  numerical experiments in reference [2].","category":"page"},{"location":"pages/t006_dg_discretization/#Manufactured-solution-1","page":"6 Poisson equation (with DG)","title":"Manufactured solution","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We start by loading the Gridap library and defining the manufactured solution u and the associated source term f and Dirichlet function g.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"using Gridap\nu(x) = 3*x[1] + x[2]^2 + 2*x[3]^3 + x[1]*x[2]*x[3]\nf(x) = -2 - 12*x[3]\ng(x) = u(x)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We also need to define the gradient of u since we will compute the H^1 error norm later. In that case, the gradient is simply defined as","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"∇u(x) = VectorValue(3        + x[2]*x[3],\n                    2*x[2]   + x[1]*x[3],\n                    6*x[3]^2 + x[1]*x[2])","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In addition, we need to tell the Gridap library that the gradient of the function u is available in the function ∇u (at this moment u and ∇u are two standard Julia functions without any connection between them). This is done by adding an extra method to the function gradient (aka ∇) defined in Gridap:","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"import Gridap: ∇\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Now, it is possible to recover function ∇u from function u as ∇(u). You  can check that the following expression evaluates to true.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"∇(u) === ∇u","category":"page"},{"location":"pages/t006_dg_discretization/#Cartesian-mesh-generation-1","page":"6 Poisson equation (with DG)","title":"Cartesian mesh generation","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In order to discretize the geometry of the unit cube, we use the Cartesian mesh generator available in Gridap.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"L = 1.0\ndomain = (0.0, L, 0.0, L, 0.0, L)\nn = 4\npartition = (n,n,n)\nmodel = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The type CartesianDiscreteModel is a concrete type that inherits from DiscreteModel, which is specifically designed for building Cartesian meshes. The CartesianDiscreteModel constructor takes a tuple containing limits of the box we want to discretize plus a tuple with the number of cells to be generated in each direction (here 4times4times4 cells). You can write the model in vtk format to visualize it (see next figure).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":" writevtk(model,\"model\")","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Note that the CaresianDiscreteModel is implemented for arbitrary  dimensions. For instance, the following lines build a  CartesianDiscreteModel for the unit square (01)^2 with 4 cells per  direction","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"domain2D = (0.0, L, 0.0, L)\npartition2D = (n,n)\nmodel2D = CartesianDiscreteModel(domain2D,partition2D)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"You could also generate a mesh for the unit tesseract (01)^4 (i.e., the unit cube in 4D). Look how the 2D and 3D models are built and just follow the sequence.","category":"page"},{"location":"pages/t006_dg_discretization/#FE-spaces-1","page":"6 Poisson equation (with DG)","title":"FE spaces","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"On top of the discrete model, we create the discontinuous space V as follows","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"order = 3\nV = TestFESpace(model,\n                ReferenceFE(lagrangian,Float64,order),\n                conformity=:L2)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We have select a Lagrangian, scalar-valued interpolation of order 3 within the cells of the discrete model. Since the cells are hexahedra, the resulting Lagrangian shape functions are tri-cubic polynomials. In contrast to previous tutorials, where we have constructed H^1-conforming (i.e., continuous) FE spaces, here we construct a L^2-conforming (i.e., discontinuous) FE space. That is, we do not impose any type of continuity of the shape function on the cell boundaries, which leads to the discontinuous FE space V of the DG formulation. Note also that we do not pass any information about the Dirichlet boundary to the TestFESpace constructor since the Dirichlet boundary conditions are not imposed strongly in this example.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"From the V object we have constructed in previous code snippet, we build the trial FE space as usual.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"U = TrialFESpace(V)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Note that we do not pass any Dirichlet function to the TrialFESpace constructor since we do not impose Dirichlet boundary conditions strongly here.","category":"page"},{"location":"pages/t006_dg_discretization/#Numerical-integration-1","page":"6 Poisson equation (with DG)","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Once the FE spaces are ready, the next step is to set up the numerical integration. In this example, we need to integrate in three different domains: the volume covered by the cells mathcalT (i.e., the computational domain Omega), the surface covered by the boundary facets mathcalF_Gamma (i.e., the boundary Gamma = partial Omega), and the surface covered by the interior facets mathcalF_Lambda (i.e. the so-called mesh skeleton). In order to integrate in Omega and on its boundary Gamma, we use Triangulation and BoundaryTriangulation objects as already discussed in previous tutorials.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Ω = Triangulation(model)\nΓ = BoundaryTriangulation(model)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Here, we do not pass any boundary identifier to the BoundaryTriangulation constructor. In this case, an integration mesh for the entire boundary Gamma is constructed by default (which is just what we need in this example).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In order to generate an integration mesh for the interior facets mathcalF_Lambda, we use a new type of Triangulation referred to as SkeletonTriangulation. It can be constructed from a DiscreteModel object as follows:","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Λ = SkeletonTriangulation(model)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"As any other type of Triangulation, an SkeletonTriangulation can be written into a vtk file for its visualization (see next figure, where the interior facets mathcalF_Lambda are clearly observed).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"writevtk(Λ,\"strian\")","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Once we have constructed the triangulations needed in this example, we define the corresponding quadrature rules by passing the triangualtions together with the desired degree to the Measure function.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"degree = 2*order\n\ndΩ = Measure(Ω,degree)\ndΓ = Measure(Γ,degree)\ndΛ = Measure(Λ,degree)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We still need a way to represent the unit outward normal vector to the boundary Gamma, and the unit normal vector on the interior faces mathcalF_Lambda. This is done with the get_normal_vector getter.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"n_Γ = get_normal_vector(Γ)\nn_Λ = get_normal_vector(Λ)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The get_normal_vector getter takes either a boundary or a skeleton triangulation and returns an object representing the normal vector to the corresponding surface. For boundary triangulations, the returned normal vector is the unit outwards one, whereas for skeleton triangulations the orientation of the returned normal is arbitrary. In the current implementation (Gridap v0.5.0), the unit normal is outwards to the cell with smaller id among the two cells that share an interior facet in mathcalF_Lambda.","category":"page"},{"location":"pages/t006_dg_discretization/#Weak-form-1","page":"6 Poisson equation (with DG)","title":"Weak form","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"With these ingredients we can define the different terms in the weak form. First, we start with the terms a_Omega(cdotcdot) , and l_Omega(cdot) associated with integrals in the volume Omega. This is done as in the tutorial for the Poisson equation.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"a_Ω(u,v) = ∫( ∇(v)⊙∇(u) )dΩ\nl_Ω(v) = ∫( v*f )dΩ","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The terms a_Gamma(cdotcdot) and l_Gamma(cdot) associated with integrals on the boundary Gamma are defined using an analogous approach:","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"h = L / n\nγ = order*(order+1)\na_Γ(u,v) = ∫( - v*(∇(u)⋅n_Γ) - (∇(v)⋅n_Γ)*u + (γ/h)*v*u )dΓ\nl_Γ(v)   = ∫(                - (∇(v)⋅n_Γ)*g + (γ/h)*v*g )dΓ","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Note that in the definition of the functions a_Γ and b_Γ, we have used the object n_Γ representing the outward unit normal to the boundary Gamma. The code definition of a_Γ and b_Γ is indeed very close to the mathematical definition of the forms a_Gamma(cdotcdot) and b_Gamma(cdot).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Finally, we need to define the term a_Lambda(cdotcdot) integrated on the interior facets mathcalF_Lambda,","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"a_Λ(u,v) = ∫( - jump(v*n_Λ)⊙mean(∇(u))\n              - mean(∇(v))⊙jump(u*n_Λ)\n              + (γ/h)*jump(v*n_Λ)⊙jump(u*n_Λ) )dΛ","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Note that the arguments v, u of function a_Λ represent a test and trial function restricted to the interior facets mathcalF_Lambda. As mentioned before in the presentation of the DG formulation, the restriction of a function vin V to the interior faces leads to two different values v^+ and v^- . In order to compute jumps and averages of the quantities v^+ and v^-, we use the functions jump and mean, which represent the jump and mean value operators lbracklbrack cdot rbrackrbrack and  cdot  respectively. Note also that we have used the object n_Λ representing the unit normal vector on the interior facets. As a result, the notation used to define function a_Λ is very close to the mathematical definition of the terms in the bilinear form a_Lambda(cdotcdot).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Once the different terms of the weak form have been defined, we build and solve the FE problem.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"a(u,v) = a_Ω(u,v) + a_Γ(u,v) + a_Λ(u,v)\nl(v) = l_Ω(v) + l_Γ(v)\n\nop = AffineFEOperator(a, l, U, V)\nuh = solve(op)","category":"page"},{"location":"pages/t006_dg_discretization/#Discretization-error-1","page":"6 Poisson equation (with DG)","title":"Discretization error","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We end this tutorial by quantifying the discretization error associated with the computed numerical solution uh. In DG methods a simple error indicator is the jump of the computed (discontinuous) approximation on the interior faces. We compute and visualize the jump of these values as follows (see next figure):","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"writevtk(Λ,\"jumps\",cellfields=[\"jump_u\"=>jump(uh)])","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Note that the jump of the numerical solution is very small, close to the machine precision (as expected in this example with manufactured solution). (Image: )","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"A more rigorous way of quantifying the error is to measure it with a norm.  Here, we use the L^2 and H^1 norms, namely","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\n  w _L^2^2  doteq int_Omega w^2  textdOmega \n  w _H^1^2  doteq int_Omega w^2 + nabla w cdot nabla w  textdOmega\nendaligned","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The discretization error can be computed in this example as the difference of the manufactured and numerical solutions.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"e = u - uh","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We compute the error norms as follows. First, we implement the integrands of the norms we want to compute.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"l2(u) = sqrt(sum( ∫( u⊙u )*dΩ ))\nh1(u) = sqrt(sum( ∫( u⊙u + ∇(u)⊙∇(u) )*dΩ ))","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"Then, we compute the corresponding integrals with the integrate function.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"el2 = l2(e)\neh1 = h1(e)","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The integrate function returns a lazy object representing the contribution to the integral of each cell in the underlying triangulation. To end up with the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are close to machine precision (as one would expect).","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"tol = 1.e-10\n@assert el2 < tol\n@assert eh1 < tol","category":"page"},{"location":"pages/t006_dg_discretization/#References-1","page":"6 Poisson equation (with DG)","title":"References","text":"","category":"section"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"[1] D. N. Arnold, F. Brezzi, B. Cockburn, and L. Donatella Marini. Unified analysis of discontinuous Galerkin methods for elliptic problems. SIAM Journal on Numerical Analysis, 39 (5):1749–1779, 2001. doi:10.1137/S0036142901384162.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"[2] B. Cockburn, G. Kanschat, and D. Schötzau. An equal-order DG method for the incompressible Navier-Stokes equations. Journal of Scientific Computing, 40(1-3):188–210, 2009. doi:10.1007/s10915-008-9261-1.","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"","category":"page"},{"location":"pages/t006_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/emscatter.jl\"","category":"page"},{"location":"pages/t012_emscatter/#Tutorial-12:-Electromagnetic-scattering-in-2D-1","page":"12 Electromagnetic scattering in 2D","title":"Tutorial 12: Electromagnetic scattering in 2D","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"In this tutorial, we will learn:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"How to formulate the weak form for a scalar time-harmonic electromagnetic problem\nHow to implement a perfectly matched layer (PML) to absorb outgoing waves\nHow to impose periodic boundary conditions in Gridap\nHow to discretize PDEs with complex-valued solutions","category":"page"},{"location":"pages/t012_emscatter/#Problem-statement-1","page":"12 Electromagnetic scattering in 2D","title":"Problem statement","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We are going to solve a scalar electromagnetic wave scattering problem: a plane wave (Hz-polarized H_inc) scattering of a dielectric cylinder (of radius R and permittivity varepsilon), as illustrated below. The computational cell is of height H and length L, and we employ a perfectly matched layer (PML) thickness of d_pml to implement outgoing (radiation) boundary conditions for this finite domain.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"(Image: )","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"From Maxwell's equations, considering a time-harmonic electromagnetic field, we can derive the governing equation of this problem in 2D (Helmholtz equation) [1]:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"left-nablacdotfrac1varepsilon(x)nabla -k^2mu(x)right H = f(x)","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where k=omegac is the wave number in free space and f(x) is the source term (which corresponds to a magnetic current density in Maxwell's equations).","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"In order to simulate this scattering problem in a finite computation cell, we need outgoing (radiation) boundary conditions such that all waves at the boundary would not be reflected back since we are simulating an infinite space. One commonly used technique to simulate such infinite space is through the so called \"perfectly matched layers\" (PML) [2]. Actually, PML is not a boundary condition but an artificial absorbing \"layer\" that absorbs waves with minimal reflections (going to zero as the resolution increases). There are many formulations of PML. Here, we use one of the most flexible formulations, the \"stretched-coordinate\" formulation, which takes the following replace in the PDE [3]:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"fracpartialpartial xrightarrow frac11+mathrmisigma(u_x)omegafracpartialpartial x","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"fracpartialpartial yrightarrow frac11+mathrmisigma(u_y)omegafracpartialpartial y","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where u_xy is the depth into the PML, sigma is a profile function (here we chose sigma(u)=sigma_0(ud_pml)^2) and different derivative corresponds to different absorption directions. Note that at a finite mesh resolution, PML reflects some waves, and the standard technique to mitigate this is to \"turn on\" the PML absorption gradually—in this case we use a quadratic profile. The amplitude sigma_0 is chosen so that in the limit of infinite resolution the \"round-trip\" normal-incidence is some small number.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Since PML absorbs all waves in xy direction, the associated boundary condition is then usually the zero Dirichlet boundary condition. Here, the boundary conditions are zero Dirichlet boundary on the top and bottom side Gamma_D but periodic boundary condition on the left (Gamma_L) and right side (Gamma_R). The reason that we use a periodic boundary condition for the left and right side instead of zero Dirichlet boundary condition is that we want to simulate a plane wave exicitation, which then requires a periodic boundary condition.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Consider mu(x)=1 (which is mostly the case in electromagnetic problems) and denote Lambda=operatornamediagm(Lambda_xLambda_y) where Lambda_xy=frac11+mathrmisigma(u_xy)omega, we can formulate the problem as","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"left beginaligned\nleft-Lambdanablacdotfrac1varepsilon(x)Lambdanabla -k^2right H = f(x)  text in  Omega\nH=0  text on  Gamma_D\nH_Gamma_L=H_Gamma_R\nendalignedright","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"For convenience, in the weak form and Julia implementation below we represent Lambda as a vector instead of a diagonal 2 times 2 matrix, in which case Lambdanabla becomes the elementwise product.","category":"page"},{"location":"pages/t012_emscatter/#Numerical-scheme-1","page":"12 Electromagnetic scattering in 2D","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Similar to the previous tutorials, we need to construct the weak form for the above PDEs. After integral by part and removing the zero boundary integral term, we get:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"a(uv) = int_Omega leftnabla(Lambda v)cdotfrac1varepsilon(x)Lambdanabla u-k^2uvrightmathrmdOmega","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"b(v) = int_Omega vfmathrmdOmega","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Notice that the nabla(Lambda v) is also a element-wise \"product\" of two vectors nabla and Lambda v.","category":"page"},{"location":"pages/t012_emscatter/#Setup-1","page":"12 Electromagnetic scattering in 2D","title":"Setup","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We import the packages that will be used, define the geometry and physics parameters.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"using Gridap\nusing GridapGmsh\nusing Gridap.Fields\nusing Gridap.Geometry\n\nλ = 1.0          # Wavelength (arbitrary unit)\nL = 4.0          # Width of the area\nH = 6.0          # Height of the area\nxc = [0 -1.0]    # Center of the cylinder\nr = 1.0          # Radius of the cylinder\nd_pml = 0.8      # Thickness of the PML\nk = 2*π/λ        # Wave number\nconst ϵ₁ = 3.0   # Relative electric permittivity for cylinder","category":"page"},{"location":"pages/t012_emscatter/#Discrete-Model-1","page":"12 Electromagnetic scattering in 2D","title":"Discrete Model","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We import the model from the geometry.msh mesh file using the GmshDiscreteModel function defined in GridapGmsh. The mesh file is created with GMSH in Julia (see the file ../assets/emscatter/MeshGenerator.jl). Note that this mesh file already contains periodic boundary information for the left and right side, and that is enough for gridap to realize a periodic boundary condition should be implemented.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"model = GmshDiscreteModel(\"../models/geometry.msh\")","category":"page"},{"location":"pages/t012_emscatter/#FE-spaces-1","page":"12 Electromagnetic scattering in 2D","title":"FE spaces","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We use the first-order lagrangian as the finite element function space basis. The dirihlet edges are labeld with DirichletEdges in the mesh file. Since our problem involves complex numbers (because of PML), we need to assign the vector_type to be Vector{ComplexF64}.","category":"page"},{"location":"pages/t012_emscatter/#Test-and-trial-finite-element-function-space-1","page":"12 Electromagnetic scattering in 2D","title":"Test and trial finite element function space","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe,dirichlet_tags=\"DirichletEdges\",vector_type=Vector{ComplexF64})\nU = V # mathematically equivalent to TrialFESpace(V,0)","category":"page"},{"location":"pages/t012_emscatter/#Numerical-integration-1","page":"12 Electromagnetic scattering in 2D","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We generate the triangulation and a second-order Gaussian quadrature for the numerial integration. Note that we create a boundary triangulation from a Source tag for the line excitation. Generally, we do not need such additional mesh tags for the source, we can use a delta function to approximate such line source excitation. However, by generating a line mesh, we can increase the accuracy of this source excitation.","category":"page"},{"location":"pages/t012_emscatter/#Generate-triangulation-and-quadrature-from-model-1","page":"12 Electromagnetic scattering in 2D","title":"Generate triangulation and quadrature from model","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"degree = 2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t012_emscatter/#Source-triangulation-1","page":"12 Electromagnetic scattering in 2D","title":"Source triangulation","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Γ = BoundaryTriangulation(model;tags=\"Source\")\ndΓ = Measure(Γ,degree)","category":"page"},{"location":"pages/t012_emscatter/#PML-formulation-1","page":"12 Electromagnetic scattering in 2D","title":"PML formulation","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Here we first define a s_PML function: s(x)=1+mathrmisigma(u)omega and its derivative ds_PML. The parameter LH indicates the size of the inner boundary of the PML regions. Finally, we create a function-like object Λ that returns the PML factors and define its derivative in gridap. Note that here we are defining a \"callable object\" of type Λ that encapsulates all of the PML parameters. This is convenient, both because we can pass lots of parameters around easily and also because we can define additional methods on Λ, e.g. to express the ∇(Λv) operation.","category":"page"},{"location":"pages/t012_emscatter/#PML-parameters-1","page":"12 Electromagnetic scattering in 2D","title":"PML parameters","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Rpml = 1e-12      # Tolerence for PML reflection\nσ = -3/4*log(Rpml)/d_pml # σ_0\nLH = (L,H) # Size of the PML inner boundary (a rectangular centere at (0,0))","category":"page"},{"location":"pages/t012_emscatter/#PML-coordinate-streching-functions-1","page":"12 Electromagnetic scattering in 2D","title":"PML coordinate streching functions","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"function s_PML(x,σ,k,LH,d_pml)\n    u = abs.(Tuple(x)).-LH./2  # get the depth into PML\n    return @. ifelse(u > 0,  1+(1im*σ/k)*(u/d_pml)^2, $(1.0+0im))\nend\n\nfunction ds_PML(x,σ,k,LH,d_pml)\n    u = abs.(Tuple(x)).-LH./2 # get the depth into PML\n    ds = @. ifelse(u > 0, (2im*σ/k)*(1/d_pml)^2*u, $(0.0+0im))\n    return ds.*sign.(Tuple(x))\nend\n\nstruct Λ<:Function\n    σ::Float64\n    k::Float64\n    LH::NTuple{2,Float64}\n    d_pml::Float64\nend\n\nfunction (Λf::Λ)(x)\n    s_x,s_y = s_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)\n    return VectorValue(1/s_x,1/s_y)\nend\n\nFields.∇(Λf::Λ) = x->TensorValue{2,2,ComplexF64}(-(Λf(x)[1])^2*ds_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)[1],0,0,-(Λf(x)[2])^2*ds_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)[2])","category":"page"},{"location":"pages/t012_emscatter/#Weak-form-1","page":"12 Electromagnetic scattering in 2D","title":"Weak form","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"In the mesh file, we labeled the cylinder region with Cylinder to distinguish it from other regions. Using this tag, we can assign material properties correspondingly (basically a function with different value in different regions). The weak form is very similar to its mathematical form in gridap.","category":"page"},{"location":"pages/t012_emscatter/#Intermediate-variables-1","page":"12 Electromagnetic scattering in 2D","title":"Intermediate variables","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"labels = get_face_labeling(model)\ndimension = num_cell_dims(model)\ntags = get_face_tag(labels,dimension)\nconst cylinder_tag = get_tag_from_name(labels,\"Cylinder\")\n\nfunction ξ(tag)\n    if tag == cylinder_tag\n        return 1/ϵ₁\n    else\n        return 1.0\n    end\nend\n\nτ = CellField(tags,Ω)\nΛf = Λ(σ,k,LH,d_pml)","category":"page"},{"location":"pages/t012_emscatter/#Bi-linear-term-(from-weak-form)-1","page":"12 Electromagnetic scattering in 2D","title":"Bi-linear term (from weak form)","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Note that we use a element-wise product .* here for the vector-vector product Lambda nabla","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"a(u,v) = ∫(  (∇.*(Λf*v))⊙((ξ∘τ)*(Λf.*∇(u))) - (k^2*(v*u))  )dΩ","category":"page"},{"location":"pages/t012_emscatter/#Source-term-(uniform-line-source)-1","page":"12 Electromagnetic scattering in 2D","title":"Source term (uniform line source)","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"b(v) = ∫(v)*dΓ","category":"page"},{"location":"pages/t012_emscatter/#Solver-phase-1","page":"12 Electromagnetic scattering in 2D","title":"Solver phase","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"We can assemble the finite element operator in Gridap with the bi-linear and linear form, then solve for the field.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"op = AffineFEOperator(a,b,U,V)\nuh = solve(op)","category":"page"},{"location":"pages/t012_emscatter/#Analytical-solution-1","page":"12 Electromagnetic scattering in 2D","title":"Analytical solution","text":"","category":"section"},{"location":"pages/t012_emscatter/#Theoretical-analysis-1","page":"12 Electromagnetic scattering in 2D","title":"Theoretical analysis","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"In this section, we construct the semi-analytical solution to this scattering problem, for comparison to the numerical solution. This is possible because of the symmetry of the cylinder, which allows us to expand the solutions of the Helmoltz equation in Bessel functions and match boundary conditions at the cylinder interface. (In 3d, the analogous process with spherical harmonics is known as \"Mie scattering\".) For more information on this technique, see Ref [4]. In 2D cylinder coordinates, we can expand the plane wave in terms of Bessel functions (this is the Jacobi–Anger identity [5]):","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H_0=sum_m i^mJ_m(kr)e^imtheta","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where m=0pm 1pm 2dots and J_m(z) is the Bessel function of the fisrt kind.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"For simplicity, we start with only the m-th component and take it as the incident part:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H_inc=J_m(kr)","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"For the scattered field, since the scattered wave should be going out, we can then expand it in terms of the Hankel function of the first kind (outgoing and incoming cylindrical waves are Hankel functions of the first and second kind [6]):","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H_1=alpha_mH_m^1(kr)","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"For the fields inside the cylinder, we require the field to be finite at r=0, which then constrains the field to be only the expansion of the Bessel functions:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H_2=beta_mJ_m(nkr)","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where n=sqrtvarepsilon is the refractive index.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Applying the boundary conditions (tangential part of the electric and magnetic field to be continuous):","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H_inc+H_1=H_2_r=R","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"fracpartial H_incpartial r+fracpartial H_1partial r=frac1epsilonfracpartial H_2partial r_r=R","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"After some math, we get:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"alpha_m=fracJ_m(nkR)J_m(kR)^prime-frac1nJ_m(kR)J_m(nkR)^primefrac1nH_m^1(kR)J_m(nkr)^prime-J_m(nkr)H_m^1(kr)^prime","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"beta_m = fracH_m^1(kR)J_m(kR)^prime-J_m(kR)H_m^1(kR)^primefrac1nJ_m(nkR)^prime H_m^1(kR)-J_m(nkR)H_m^1(kR)^prime","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where ^prime denotes the derivative, and the derivatives of the Bessel functions are obtained with the recurrent relations:","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Y_m(z)^prime=fracY_m-1(z)-Y_m+1(z)2","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"where Y_m denotes any Bessel functions (Hankel functions).","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"Finally, the analytical field is (12k is the amplitude that comes from the unit line source excitation):","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H(rR)=frac12ksum_mleftalpha_mi^mH_m^1(kr)+J_m(kr)righte^imtheta","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"H(rleq R)=frac12ksum_mbeta_mi^mJ_m(nkr)e^imtheta","category":"page"},{"location":"pages/t012_emscatter/#Define-the-analytical-functions-1","page":"12 Electromagnetic scattering in 2D","title":"Define the analytical functions","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"using SpecialFunctions\ndbesselj(m,z) = (besselj(m-1,z)-besselj(m+1,z))/2\ndhankelh1(m,z)= (hankelh1(m-1,z)-hankelh1(m+1,z))/2\nα(m,n,z) = (besselj(m,n*z)*dbesselj(m,z)-1/n*besselj(m,z)*dbesselj(m,n*z))/(1/n*hankelh1(m,z)*dbesselj(m,n*z)-besselj(m,n*z)*dhankelh1(m,z))\nβ(m,n,z) = (hankelh1(m,z)*dbesselj(m,z)-besselj(m,z)*dhankelh1(m,z))/(1/n*dbesselj(m,n*z)*hankelh1(m,z)-besselj(m,n*z)*dhankelh1(m,z))\n\nfunction H_t(x,xc,r,ϵ,λ)\n    n = √ϵ\n    k = 2*π/λ\n    θ = angle(x[1]-xc[1]+1im*(x[2]-xc[2]))+π\n    M = 40 # Number of Bessel function basis used\n    H0 = 0\n    if norm([x[1]-xc[1],x[2]-xc[2]])<=r\n        for m=-M:M\n            H0 += β(m,n,k*r)*cis(m*θ)*besselj(m,n*k*norm([x[1]-xc[1],x[2]-xc[2]]))\n        end\n    else\n        for m=-M:M\n            H0 += α(m,n,k*r)*cis(m*θ)*hankelh1(m,k*norm([x[1]-xc[1],x[2]-xc[2]]))+cis(m*θ)*besselj(m,k*norm([x[1]-xc[1],x[2]-xc[2]]))\n        end\n    end\n    return 1im/(2*k)*H0\nend","category":"page"},{"location":"pages/t012_emscatter/#Construct-the-analytical-solution-in-finite-element-basis-1","page":"12 Electromagnetic scattering in 2D","title":"Construct the analytical solution in finite element basis","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"uh_t = CellField(x->H_t(x,xc,r,ϵ₁,λ),Ω)","category":"page"},{"location":"pages/t012_emscatter/#Output-and-compare-results-1","page":"12 Electromagnetic scattering in 2D","title":"Output and compare results","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"The simulated field is shown below. We can see that the simulated fields and the analytical solution matched closed except for the top and PML regions. This is because the simulated source generate plane waves in two directions but we only consider the downward propagating wave in the analytical solution and the PML effect is also not considered in the analytical solution. Therefore, we just need to focus on the \"center\" regions which excludes the PML and top region above the source, the difference is within 6% of the field amplitude integral. As we increase the resolution, this difference should decrease (until it becomes limited by the PML reflection coefficient from sigma_0, the number of Bessel function basis M or by floating-point error.) (Image: )","category":"page"},{"location":"pages/t012_emscatter/#Save-to-file-and-view-1","page":"12 Electromagnetic scattering in 2D","title":"Save to file and view","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"writevtk(Ω,\"demo\",cellfields=[\"Real\"=>real(uh),\n        \"Imag\"=>imag(uh),\n        \"Norm\"=>abs2(uh),\n        \"Real_t\"=>real(uh_t),\n        \"Imag_t\"=>imag(uh_t),\n        \"Norm_t\"=>abs2(uh_t),\n        \"Difference\"=>abs(uh_t-uh)])","category":"page"},{"location":"pages/t012_emscatter/#Compare-the-difference-in-the-\"center\"-region-1","page":"12 Electromagnetic scattering in 2D","title":"Compare the difference in the \"center\" region","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"function AnalyticalBox(x) # Get the \"center\" region\n    if abs(x[1])<L/2 && abs(x[2]+0.5)<2.5\n        return 1\n    else\n        return 0\n    end\nend\n\nDifference=sqrt(sum(∫(abs2(uh_t-uh)*AnalyticalBox)*dΩ)/sum(∫(abs2(uh_t)*AnalyticalBox)*dΩ))\n\n@assert Difference < 0.1","category":"page"},{"location":"pages/t012_emscatter/#References-1","page":"12 Electromagnetic scattering in 2D","title":"References","text":"","category":"section"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[1] Wikipedia: Electromagnetic wave equation","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[2] Wikipedia: Perfectly matched layer","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[3] A. Oskooi and S. G. Johnson, “Distinguishing correct from incorrect PML proposals and a corrected unsplit PML for anisotropic, dispersive media,” Journal of Computational Physics, vol. 230, pp. 2369–2377, April 2011.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[4] Stratton, J. A. (1941). Electromagnetic Theory. New York: McGraw-Hill.","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[5] Wikipedia: Jacobi–Anger expansion","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"[6] Wikipedia: Bessel function","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"","category":"page"},{"location":"pages/t012_emscatter/#","page":"12 Electromagnetic scattering in 2D","title":"12 Electromagnetic scattering in 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/stokes.jl\"","category":"page"},{"location":"pages/t009_stokes/#Tutorial-9:-Stokes-equation-1","page":"9 Stokes equation","title":"Tutorial 9: Stokes equation","text":"","category":"section"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"note: Note\nThis tutorial is under construction, but the code below is already functional.","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Driver that computes the lid-driven cavity benchmark at low Reynolds numbers when using a mixed FE Q(k)/Pdisc(k-1).","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Load Gridap library","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"using Gridap","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Discrete model","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"n = 100\ndomain = (0,1,0,1)\npartition = (n,n)\nmodel = CartesianDiscreteModel(domain, partition)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define Dirichlet boundaries","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"labels = get_face_labeling(model)\nadd_tag_from_tags!(labels,\"diri1\",[6,])\nadd_tag_from_tags!(labels,\"diri0\",[1,2,3,4,5,7,8])","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define reference FE (Q2/P1(disc) pair)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"order = 2\nreffeᵤ = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\nreffeₚ = ReferenceFE(lagrangian,Float64,order-1;space=:P)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define test FESpaces","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"V = TestFESpace(model,reffeᵤ,labels=labels,dirichlet_tags=[\"diri0\",\"diri1\"],conformity=:H1)\nQ = TestFESpace(model,reffeₚ,conformity=:L2,constraint=:zeromean)\nY = MultiFieldFESpace([V,Q])","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define trial FESpaces from Dirichlet values","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"u0 = VectorValue(0,0)\nu1 = VectorValue(1,0)\nU = TrialFESpace(V,[u0,u1])\nP = TrialFESpace(Q)\nX = MultiFieldFESpace([U,P])","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define triangulation and integration measure","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"degree = order\nΩₕ = Triangulation(model)\ndΩ = Measure(Ωₕ,degree)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Define bilinear and linear form","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"f = VectorValue(0.0,0.0)\na((u,p),(v,q)) = ∫( ∇(v)⊙∇(u) - (∇⋅v)*p + q*(∇⋅u) )dΩ\nl((v,q)) = ∫( v⋅f )dΩ","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Build affine FE operator","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"op = AffineFEOperator(a,l,X,Y)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Solve","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"uh, ph = solve(op)","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"Export results to vtk","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"writevtk(Ωₕ,\"results\",order=2,cellfields=[\"uh\"=>uh,\"ph\"=>ph])","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"","category":"page"},{"location":"pages/t009_stokes/#","page":"9 Stokes equation","title":"9 Stokes equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/isotropic_damage.jl\"","category":"page"},{"location":"pages/t010_isotropic_damage/#Tutorial-10:-Isotropic-damage-model-1","page":"10 Isotropic damage model","title":"Tutorial 10: Isotropic damage model","text":"","category":"section"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"note: Note\nThis tutorial is under construction, but the code below is already functional.","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"using Gridap\nusing LinearAlgebra","category":"page"},{"location":"pages/t010_isotropic_damage/#Model-definition-1","page":"10 Isotropic damage model","title":"Model definition","text":"","category":"section"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Elastic branch","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"const E = 3.0e10 # Pa\nconst ν = 0.3 # dim-less\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\nσe(ε) = λ*tr(ε)*one(ε) + 2*μ*ε # Pa\nτ(ε) = sqrt(ε ⊙ σe(ε)) # Pa^(1/2)","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Damage","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"const σ_u = 4.0e5 # Pa\nconst r_0 = σ_u / sqrt(E) # Pa^(1/2)\nconst H = 0.5 # dim-less\n\nfunction d(r)\n  1 - q(r)/r\nend\n\nfunction q(r)\n  r_0 + H*(r-r_0)\nend","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Update of the state variables","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"function new_state(r_in,d_in,ε_in)\n  τ_in = τ(ε_in)\n  if τ_in <= r_in\n    r_out = r_in\n    d_out = d_in\n    damaged = false\n  else\n    r_out = τ_in\n    d_out = d(r_out)\n    damaged = true\n  end\n  damaged, r_out, d_out\nend","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Constitutive law and its linearization","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"function σ(ε_in,r_in,d_in)\n  _, _, d_out = new_state(r_in,d_in,ε_in)\n  (1-d_out)*σe(ε_in)\nend\n\nfunction dσ(dε_in,ε_in,state)\n  damaged, r_out, d_out = state\n  if ! damaged\n    return (1-d_out)*σe(dε_in)\n  else\n    c_inc = ((q(r_out) - H*r_out)*(σe(ε_in) ⊙ dε_in))/(r_out^3)\n    return (1-d_out)*σe(dε_in) - c_inc*σe(ε_in)\n  end\nend","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"max dead load","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"const b_max = VectorValue(0.0,0.0,-(9.81*2.5e3))","category":"page"},{"location":"pages/t010_isotropic_damage/#L2-projection-1","page":"10 Isotropic damage model","title":"L2 projection","text":"","category":"section"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"form Gauss points to a Lagrangian piece-wise discontinuous space","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"function project(q,model,dΩ,order)\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = FESpace(model,reffe,conformity=:L2)\n  a(u,v) = ∫( u*v )*dΩ\n  l(v) = ∫( v*q )*dΩ\n  op = AffineFEOperator(a,l,V,V)\n  qh = solve(op)\n  qh\nend","category":"page"},{"location":"pages/t010_isotropic_damage/#Main-function-1","page":"10 Isotropic damage model","title":"Main function","text":"","category":"section"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"function main(;n,nsteps)\n\n  r = 12\n  domain = (0,r,0,1,0,1)\n  partition = (r*n,n,n)\n  model = CartesianDiscreteModel(domain,partition)\n\n  labeling = get_face_labeling(model)\n  add_tag_from_tags!(labeling,\"supportA\",[1,3,5,7,13,15,17,19,25])\n  add_tag_from_tags!(labeling,\"supportB\",[2,4,6,8,14,16,18,20,26])\n  add_tag_from_tags!(labeling,\"supports\",[\"supportA\",\"supportB\"])\n\n  order = 1\n\n  reffe = ReferenceFE(lagrangian,VectorValue{3,Float64},order)\n  V = TestFESpace(model,reffe,labels=labeling,dirichlet_tags=[\"supports\"])\n  U = TrialFESpace(V)\n\n  degree = 2*order\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,degree)\n\n  r = CellState(r_0,dΩ)\n  d = CellState(0.0,dΩ)\n\n  nls = NLSolver(show_trace=true, method=:newton)\n  solver = FESolver(nls)\n\n  function step(uh_in,factor,cache)\n    b = factor*b_max\n    res(u,v) = ∫(  ε(v) ⊙ (σ∘(ε(u),r,d))  - v⋅b )*dΩ\n    jac(u,du,v) = ∫(  ε(v) ⊙ (dσ∘(ε(du),ε(u),new_state∘(r,d,ε(u))))  )*dΩ\n    op = FEOperator(res,jac,U,V)\n    uh_out, cache = solve!(uh_in,solver,op,cache)\n    update_state!(new_state,r,d,ε(uh_out))\n    uh_out, cache\n  end\n\n  factors = collect(1:nsteps)*(1/nsteps)\n  uh = zero(V)\n  cache = nothing\n\n  for (istep,factor) in enumerate(factors)\n\n    println(\"\\n+++ Solving for load factor $factor in step $istep of $nsteps +++\\n\")\n\n    uh,cache = step(uh,factor,cache)\n    dh = project(d,model,dΩ,order)\n    rh = project(r,model,dΩ,order)\n\n    writevtk(\n      Ω,\"results_$(lpad(istep,3,'0'))\",\n      cellfields=[\"uh\"=>uh,\"epsi\"=>ε(uh),\"damage\"=>dh,\n                  \"threshold\"=>rh,\"sigma_elast\"=>σe∘ε(uh)])\n\n  end\n\nend","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Run!","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"main(n=6,nsteps=20)","category":"page"},{"location":"pages/t010_isotropic_damage/#Results-1","page":"10 Isotropic damage model","title":"Results","text":"","category":"section"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"Animation of the load history using for main(n=8,nsteps=30) (Image: )","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"","category":"page"},{"location":"pages/t010_isotropic_damage/#","page":"10 Isotropic damage model","title":"10 Isotropic damage model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/interpolation_fe.jl\"","category":"page"},{"location":"pages/t015_interpolation_fe/#Tutorial-15:-Interpolation-of-CellFields-1","page":"15 Interpolation of CellFields","title":"Tutorial 15: Interpolation of CellFields","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"In this tutorial, we will look at how to","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Evaluate CellFields at arbitrary points\nInterpolate finite element functions defined on different","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"triangulations. We will consider examples for","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Lagrangian finite element spaces\nRaviart Thomas finite element spaces\nVector-Valued Spaces\nMultifield finite element spaces","category":"page"},{"location":"pages/t015_interpolation_fe/#Problem-Statement-1","page":"15 Interpolation of CellFields","title":"Problem Statement","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Let mathcalT_1 and mathcalT_2 be two triangulations of a domain Omega. Let V_i be the finite element space defined on the triangulation mathcalT_i for i=12. Let f_h in V_1. The interpolation problem is to find g_h in V_2 such that","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"dof_k^V_2(g_h) = dof_k^V_2(f_h)quad forall k in\n1dotsN_dof^V_2","category":"page"},{"location":"pages/t015_interpolation_fe/#Setup-1","page":"15 Interpolation of CellFields","title":"Setup","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"For the purpose of this tutorial we require Test, Gridap along with the following submodules of Gridap","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"using Test\nusing Gridap\nusing Gridap.CellData\nusing Gridap.Visualization","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We now create a computational domain on the unit square 01^2 consisting of 5 cells per direction","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"domain = (0,1,0,1)\npartition = (5,5)\n𝒯₁ = CartesianDiscreteModel(domain, partition)","category":"page"},{"location":"pages/t015_interpolation_fe/#Background-1","page":"15 Interpolation of CellFields","title":"Background","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Gridap offers the feature to evaluate functions at arbitrary points in the domain. This will be shown in the next section. Interpolation then takes advantage of this feature to obtain the FEFunction in the new space from the old one by evaluating the appropriate degrees of freedom. Interpolation works using the composite type Interpolable to tell Gridap that the argument can be interpolated between triangulations.","category":"page"},{"location":"pages/t015_interpolation_fe/#Interpolating-between-Lagrangian-FE-Spaces-1","page":"15 Interpolation of CellFields","title":"Interpolating between Lagrangian FE Spaces","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Let us define the infinite dimensional function","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"f(x) = x[1] + x[2]","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"This function will be interpolated to the source FESpace V_1. The space can be built using","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₁ = ReferenceFE(lagrangian, Float64, 1)\nV₁ = FESpace(𝒯₁, reffe₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Finally to build the function f_h, we do","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"fₕ = interpolate_everywhere(f,V₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"To construct arbitrary points in the domain, we use Random package:","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"using Random\npt = Point(rand(2))\npts = [Point(rand(2)) for i in 1:3]","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"The finite element function f_h can be evaluated at arbitrary points (or array of points) by","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"fₕ(pt), fₕ.(pts)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can also check our results using","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"@test fₕ(pt) ≈ f(pt)\n@test fₕ.(pts) ≈ f.(pts)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Now let us define the new triangulation mathcalT_2 of Omega. We build the new triangulation using a partition of 20 cells per direction. The map can be passed as an argument to CartesianDiscreteModel to define the position of the vertices in the new mesh.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"partition = (20,20)\n𝒯₂ = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"As before, we define the new FESpace consisting of second order elements","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₂ = ReferenceFE(lagrangian, Float64, 2)\nV₂ = FESpace(𝒯₂, reffe₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Now we interpolate f_h onto V_2 to obtain the new function g_h. The first step is to create the Interpolable version of f_h.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"ifₕ = Interpolable(fₕ)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Then to obtain g_h, we dispatch ifₕ and the new FESpace V_2 to the interpolate_everywhere method of Gridap.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"gₕ = interpolate_everywhere(ifₕ, V₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can also use interpolate if interpolating only on the free dofs or interpolate_dirichlet if interpolating the Dirichlet dofs of the FESpace.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"ḡₕ = interpolate(ifₕ, V₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"The finite element function barg_h is the same as g_h in this example since all the dofs are free.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"@test gₕ.cell_dof_values ==  ḡₕ.cell_dof_values","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Now we obtain a finite element function using interpolate_dirichlet","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"g̃ₕ = interpolate_dirichlet(ifₕ, V₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Now tildeg_h will be equal to 0 since there are no Dirichlet nodes defined in the FESpace. We can check by running","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"g̃ₕ.cell_dof_values","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Like earlier we can check our results for gₕ:","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"@test fₕ(pt) ≈ gₕ(pt) ≈ f(pt)\n@test fₕ.(pts) ≈ gₕ.(pts) ≈ f.(pts)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can visualize the results using Paraview","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"writevtk(get_triangulation(fₕ), \"source\", cellfields=[\"fₕ\"=>fₕ])\nwritevtk(get_triangulation(gₕ), \"target\", cellfields=[\"gₕ\"=>gₕ])","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"which produces the following output","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"(Image: Target)","category":"page"},{"location":"pages/t015_interpolation_fe/#Interpolating-between-Raviart-Thomas-FESpaces-1","page":"15 Interpolation of CellFields","title":"Interpolating between Raviart-Thomas FESpaces","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"The procedure is identical to Lagrangian finite element spaces, as discussed in the previous section. The extra thing here is that functions in Raviart-Thomas spaces are vector-valued. The degrees of freedom of the RT spaces are fluxes of the function across the edge of the element. Refer to the tutorial on Darcy equation with RT for more information on the RT elements.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Assuming a function","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"f(x) = VectorValue([x[1], x[2]])","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"on the domain, we build the associated finite dimensional version f_h in V_1.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₁ = ReferenceFE(raviart_thomas, Float64, 1) # RT space of order 1\nV₁ = FESpace(𝒯₁, reffe₁)\nfₕ = interpolate_everywhere(f, V₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"As before, we can evaluate the RT function on any arbitrary point in the domain.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"fₕ(pt), fₕ.(pts)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Constructing the target RT space and building the Interpolable object,","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₂ = ReferenceFE(raviart_thomas, Float64, 1) # RT space of order 1\nV₂ = FESpace(𝒯₂, reffe₂)\nifₕ = Interpolable(fₕ)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"we can construct the new FEFunction g_h in V_2 from f_h","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"gₕ = interpolate_everywhere(ifₕ, V₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Like earlier we can check our results","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"@test gₕ(pt) ≈ f(pt) ≈ fₕ(pt)","category":"page"},{"location":"pages/t015_interpolation_fe/#Interpolating-vector-valued-functions-1","page":"15 Interpolation of CellFields","title":"Interpolating vector-valued functions","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can also interpolate vector-valued functions across triangulations. First, we define a vector-valued function on a two-dimensional mesh.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"f(x) = VectorValue([x[1], x[1]+x[2]])","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We then create a vector-valued reference element containing linear elements along with the source finite element space V_1.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₁ = ReferenceFE(lagrangian, VectorValue{2,Float64}, 1)\nV₁ = FESpace(𝒯₁, reffe₁)\nfₕ = interpolate_everywhere(f, V₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"The target finite element space V_2 can be defined in a similar manner.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₂ = ReferenceFE(lagrangian, VectorValue{2,Float64}, 2)\nV₂ = FESpace(𝒯₂, reffe₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"The rest of the process is similar to the previous sections, i.e., define the Interpolable version of f_h and use interpolate_everywhere to find g_h in V₂.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"ifₕ = Interpolable(fₕ)\ngₕ = interpolate_everywhere(ifₕ, V₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can then check the results","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"@test gₕ(pt) ≈ f(pt) ≈ fₕ(pt)","category":"page"},{"location":"pages/t015_interpolation_fe/#Interpolating-Multi-field-Functions-1","page":"15 Interpolation of CellFields","title":"Interpolating Multi-field Functions","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Similarly, it is possible to interpolate between multi-field finite element functions. First, we define the components h_1(x) h_2(x) of a multi-field function h(x) as follows.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"h₁(x) = x[1]+x[2]\nh₂(x) = x[1]","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Next we create a Lagrangian finite element space containing linear elements.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₁ = ReferenceFE(lagrangian, Float64, 1)\nV₁ = FESpace(𝒯₁, reffe₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Next we create a MultiFieldFESpace V_1 times V_1 and interpolate the function h(x) to the source space V_1.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"V₁xV₁ = MultiFieldFESpace([V₁,V₁])\nfₕ = interpolate_everywhere([h₁, h₂], V₁xV₁)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Similarly, the target multi-field finite element space is created using Omega_2.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"reffe₂ = ReferenceFE(lagrangian, Float64, 2)\nV₂ = FESpace(𝒯₂, reffe₂)\nV₂xV₂ = MultiFieldFESpace([V₂,V₂])","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Now, to find g_h in V_2 times V_2, we first extract the components of f_h and obtain the Interpolable version of the components.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"fₕ¹, fₕ² = fₕ\nifₕ¹ = Interpolable(fₕ¹)\nifₕ² = Interpolable(fₕ²)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can then use interpolate_everywhere on the Interpolable version of the components and obtain g_h in V_2 times V_2 as follows.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"gₕ = interpolate_everywhere([ifₕ¹,ifₕ²], V₂xV₂)","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"We can then check the results of the interpolation, component-wise.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"gₕ¹, gₕ² = gₕ\n@test fₕ¹(pt) ≈ gₕ¹(pt)\n@test fₕ²(pt) ≈ gₕ²(pt)","category":"page"},{"location":"pages/t015_interpolation_fe/#Acknowledgements-1","page":"15 Interpolation of CellFields","title":"Acknowledgements","text":"","category":"section"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"Gridap contributors acknowledge support received from Google, Inc. through the Google Summer of Code 2021 project A fast finite element interpolator in Gridap.jl.","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"","category":"page"},{"location":"pages/t015_interpolation_fe/#","page":"15 Interpolation of CellFields","title":"15 Interpolation of CellFields","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/fsi_tutorial.jl\"","category":"page"},{"location":"pages/t011_fsi_tutorial/#Tutorial-11:-Fluid-Structure-Interaction-1","page":"11 Fluid-Structure Interaction","title":"Tutorial 11: Fluid-Structure Interaction","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"How to solve a surface-coupled multi-physics problem.\nConstruct FE spaces defined in different domains.\nDefine interface triangulations and integrate on them.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Problem Statement\nStrong form\nGeometry and Discrete model\nBoundary conditions and properties\nNumerical scheme\nFE spaces\nWeak form\nNumerical integration\nAlgebraic system of equations\nPost-processing\nVisualization\nQuantities of interest","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"probStat\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Problem-statement-1","page":"11 Fluid-Structure Interaction","title":"Problem statement","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"strongForm\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Strong-form-1","page":"11 Fluid-Structure Interaction","title":"Strong form","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Let Gamma_rm FS be the interface between a fluid domain Omega_rm F and a solid domain Omega_rm S. We denote by Gamma_rm FD and Gamma_rm FN the fluid boundaries with Dirichlet and Neumann conditions, respectively. The Fluid-Structure Interaction (FSI) problem reads:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"find u_rm F, p_rm F and u_rm S such that","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"leftlbrace\nbeginaligned\n-nablacdotboldsymbolsigma_rm F = f text in Omega_rm F\nnablacdot u_rm F = 0 text in  Omega_rm F\n-nablacdotboldsymbolsigma_rm S = s text in Omega_rm S\nendaligned\nright","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"satisfying the Dirichlet and Neumann boundary conditions","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"leftlbrace\nbeginaligned\nu_rm F = g_rm F text on  Gamma_rm FD\nn_rm F cdot boldsymbolsigma_rm F = 0 text on  Gamma_rm FN\nu_rm S = g_rm S text on  Gamma_rm SD\nendaligned\nright","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"and the kinematic and dynamic conditions at the fluid-solid interface","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"leftlbrace\nbeginaligned\nu_rm F = u_rm S text on  Gamma_rm FS\nn_rm F cdot boldsymbolsigma_rm F  + n_rm S cdot boldsymbolsigma_rm S  = 0 text on  Gamma_rm FS\nendaligned\nright","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Where boldsymbolsigma_rm F(u_rm Fp_rm F)=2mu_rm Fboldsymbolvarepsilon(u_rm F) - p_rm FmathbfI and boldsymbolsigma_rm S(u_rm S)=2mu_rm Sboldsymbolvarepsilon(u_rm S) +lambda_rm Str(boldsymbolvarepsilon(u_rm S))mathbfI.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"geometry\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Geometry-and-Discrete-model-1","page":"11 Fluid-Structure Interaction","title":"Geometry and Discrete model","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In this tutorial we solve the benchmark descrived in [1], consisting on a flow over an elastic flag after a cylinder. The computational domain is defined by a channel of size Omega doteq (045)times(0041), with an embedded cylinder of radius R=005 and center at C=(0202). The associated FE triangulation is denoted by mathcalT, the fluid and solid domain and their associated triangulations will be denoted by Omega_rm F, Omega_rm S, mathcalT_rm F and mathcalT_rm S, respectively.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In order to load the discrete model we first setup Gridap","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"using Gridap","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The discrete model for the elastic flag problem is generated by loading the \"../models/elasticFlag.json\" file.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"model = DiscreteModelFromFile(\"../models/elasticFlag.json\")","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We can inspect the loaded geometry and associated parts by printing to a vtk file:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"This will produce an output in which we can identify the different parts of the domain, with the associated labels and tags.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Part Notation Label Tag\nSolid-cylinder wall Gamma_rm SD_cyl \"fixed\" 1\nFluid-solid interface Gamma_rm FS \"interface\" 2\nChannel inlet Gamma_rm FD_in \"inlet\" 3\nChannel outlet Gamma_rm FN_out \"outlet\" 4\nChannel walls Gamma_rm FD_wall \"noSlip\" 5\nFluid-cylinder wall Gamma_rm FD_cyl \"cylinder\" 6\nFluid domain Omega_rm F \"fluid\" 7\nSolid domain Omega_rm S \"solid\" 8","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"(Image: )","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"conditions\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#External-conditions-and-properties-1","page":"11 Fluid-Structure Interaction","title":"External conditions and properties","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#Boundary-conditions-1","page":"11 Fluid-Structure Interaction","title":"Boundary conditions","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We apply Dirichlet boundary conditions at the channel inlet, upper and lower boundaries and on the cylinder. A parabolic profile is enforced at the channel inlet, while a no-slip condition is imposed on the remaining Dirichlet boundaries.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"leftlbrace\nbeginaligned\nu_rm Fin(xy) = 15Ufracy(H y)left(fracH2right)^2quadtextrmon Gamma_rm FD_in\nu_rm F0(xy) = 0 0quadtextrmon Gamma_rm FD_wallcupGamma_rm FD_cyl\nu_rm S0(xy) = 0 0quadtextrmon Gamma_rm SD_cyl\nendaligned\nright","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"const U = 1.0\nconst H = 0.41\nuf_in(x) = VectorValue( 1.5 * U * x[2] * ( H - x[2] ) / ( (H/2)^2 ), 0.0 )\nuf_0(x) = VectorValue( 0.0, 0.0 )\nus_0(x) = VectorValue( 0.0, 0.0 )","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We consider a free tranction condition at the channel outlet","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"n_rm F cdot boldsymbolsigma_rm F  = mathbf0quadtextrmon Gamma_rm FN","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"hN(x) = VectorValue( 0.0, 0.0 )\np_jump(x) = 0.0","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"forces\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#External-forces-1","page":"11 Fluid-Structure Interaction","title":"External forces","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In this test, the body forces acting on the fluid an solid are zero.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"f(x) = VectorValue( 0.0, 0.0 )\ns(x) = VectorValue( 0.0, 0.0 )\ng(x) = 0.0","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"properties\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Material-properties-1","page":"11 Fluid-Structure Interaction","title":"Material properties","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We use a linear elastic constitutive law for the elastic flag. Given the Young's modulus E and the Poisson ratio nu, we can compute the Lamé constants, lambda and mu, using the following function:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"function lame_parameters(E,ν)\n  λ = (E*ν)/((1+ν)*(1-2*ν))\n  μ = E/(2*(1+ν))\n  (λ, μ)\nend","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Then, we get the Lamé parameters for a solid with E=10 MPa and nu=033.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"const E_s = 1.0\nconst ν_s = 0.33\nconst (λ_s,μ_s) = lame_parameters(E_s,ν_s)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The Cauchy stress tensor for the solid part is defined by sigma_s = 2muvarepsilon + lambda tr(varepsilon)mathbfI. Note that we use the trace operator from the LinearAlgebra package. Note that this function will be used as a composition (∘), using as argument a function whose arguments depend on the coordinates, without the need of passing such coordinates as an argument. That is σ_s(ε(u)) = σ_s ∘ ε(u).","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"using LinearAlgebra: tr\nσₛ(ε) = λ_s*tr(ε)*one(ε) + 2*μ_s*ε","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"For the fluid part, we only need to define the viscosity mu_f, which we set to 001.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"const μ_f = 0.01","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The Cauchy stress tensor for the fluid part is given by sigma_f = sigma^dev_f - pmathbfI, with sigma^dev_f=2mu_f the deviatoric part of the stress. Since we use a mixed form with the pressure p as an unknown, the stress law will only involve the deviatoric part.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"σ_dev_f(ε) = 2*μ_f*ε","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"numericalScheme\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Numerical-scheme-1","page":"11 Fluid-Structure Interaction","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"feSpace\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#FE-Spaces-1","page":"11 Fluid-Structure Interaction","title":"FE Spaces","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In this tutorial we use an inf-sup stable velocity-pressure pair, P_kP_k-1 elements, with continuous velocities and pressures. We select the same velocity interpolation space for the fluid and the solid parts, defined as follows","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"V_rm X doteq  v in H^1(Omega_rm X)^d v_Tin P_k(T)^d text for all  TinmathcalT_rm X ","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"where T denotes an arbitrary cell of the FE mesh mathcalT_rm X, and P_k(T) is the usual Lagrangian FE space of order k defined on a mesh of triangles or tetrahedra. Note that the sub-index (cdot)_rm X stands for the fluid or solid parts, (cdot)_rm F or (cdot)_rm S, respectively. On the other hand, the space for the pressure is only defined in the fluid domain, Omega_rm F, and is given by","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Q doteq  q in C^0(Omega) q_Tin P_k-1(T) text for all  TinmathcalT_rm F","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Before creating the FE spaces, we first need to define the triangulation of each of the sub-domains, which are constructed restricting the global triangulation to the corresponding part. This is done by calling the Triangulation (or equivalently Interior) function with the desired geometrical part label, i.e. \"solid\" and \"fluid\", respectively. Here we create the triangulation of the global domain, mathcalT, and the solid and fluid triangulations, mathcalT_rm F and mathcalT_rm S.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Ω = Interior(model)\nΩ_s = Interior(model,tags=\"solid\")\nΩ_f = Interior(model,tags=\"fluid\")","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We also generate the triangulation and associated outer normal field for the outlet boundary, Gamma_rm FN_out, which will be used to impose a Neumann condition.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Γ_out = BoundaryTriangulation(model,tags=\"outlet\")\nn_Γout = get_normal_vector(Γ_out)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Finally, to impose the interface condition between solid and fluid, we will need the triangulation and normal field of such interface, Gamma_rm FS. The interface triangulation is generated by calling the InterfaceTriangulation function specifying the two interfacing domain triangulations. Note that the normal field will point outwards with respect to the first entry.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Γ_fs = InterfaceTriangulation(Ω_f,Ω_s)\nn_Γfs = get_normal_vector(Γ_fs)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In what follows we will assume a second-order veloticty interpolation, i.e. k=2","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"k = 2","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Now we define the reference FE for the velocity and pressure fields. The velocity field reference FE, both for fluid and solid domains, will be defined by a 2-dimensional VectorValue type :Lagrangian reference FE element of order k. The reference FE for the pressure will be given by a scalar value type :Lagrangian reference FE element of order k-1.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"reffeᵤ = ReferenceFE(lagrangian,VectorValue{2,Float64},k)\nreffeₚ = ReferenceFE(lagrangian,Float64,k-1)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Having set up all the ingredients, we can create the different FE spaces for the test functions. For the velocity FE spaces we call the TestFESpace function with the corresponding discrete model, using the velocity reference FE reffeᵤ and conformity :H1. Note that we assign different Dirichlet boundary labels for the two different parts, generating the variational spaces with homogeneous Dirichlet boundary conditions, V_rm F0 and V_rm S0 .","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Vf = TestFESpace(\n  Ω_f,\n  reffeᵤ,\n  conformity=:H1,\n  dirichlet_tags=[\"inlet\", \"noSlip\", \"cylinder\"])\n\nVs = TestFESpace(\n  Ω_s,\n  reffeᵤ,\n  conformity=:H1,\n  dirichlet_tags=[\"fixed\"])","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"For the pressure test FE space, we use the fluid discrete model, the pressure reference FE reffeₚ and :C0 conformity.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Qf = TestFESpace(\n  Ω_f,\n  reffeₚ,\n  conformity=:C0)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The trial FE spaces are generated from the test FE spaces, adding the corresponding function for the various Dirichlet boundaries, leading to U_rm Fg_rm F, U_rm Sg_rm S and P_rm F.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Uf = TrialFESpace(Vf,[uf_in, uf_0, uf_0])\nUs = TrialFESpace(Vs,[us_0])\nPf = TrialFESpace(Qf)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Finally, we glue the test and trial FE spaces together, defining a unique test and trial space for all the fields using the MultiFieldFESpace function. That is Y=V_rm S0 V_rm F0 Q_rm F^T and X=U_rm Sg_rm S U_rm Fg_rm F P_rm F^T","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Y = MultiFieldFESpace([Vs,Vf,Qf])\nX = MultiFieldFESpace([Us,Uf,Pf])","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"integration\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Numerical-integration-1","page":"11 Fluid-Structure Interaction","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Once we have all the triangulations, we can generate the quadrature rules to be applied each domain. This will be generated by calling the Measure function, that given a triangulation and an integration degree, it returns the Lebesgue integral measure dOmega.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"degree = 2*k\ndΩₛ = Measure(Ω_s,degree)\ndΩ_f = Measure(Ω_f,degree)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Idem for the boundary part.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"bdegree = 2*k\ndΓ_out = Measure(Γ_out,bdegree)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Idem for the interface part.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"idegree = 2*k\ndΓ_fs = Measure(Γ_fs,idegree)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"weakForm\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Weak-form-1","page":"11 Fluid-Structure Interaction","title":"Weak form","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"We now introduce the solution and test function vectors as mathbfu^h_rm smathbfu^h_rm s p^h_rm f^T and mathbfv^h_rm smathbfv^h_rm f q^h_rm f^T. The weak form of the coupled FSI problem using the Nitche's method, see for instance [2], reads:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"find mathbfu^h_rm smathbfu^h_rm s p^h_rm f^T in X such that","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a(mathbfu^h_rm smathbfu^h_rm s p^h_rm fmathbfv^h_rm smathbfv^h_rm f q^h_rm f)=l(mathbfv^h_rm smathbfv^h_rm f q^h_rm f)qquadforallmathbfv^h_rm smathbfv^h_rm f q^h_rm f^Tin Y","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"where","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"beginaligned\na(mathbfu^h_rm smathbfu^h_rm s p^h_rm fmathbfv^h_rm smathbfv^h_rm f q^h_rm f)doteq a_s(mathbfu^h_rm smathbfv^h_rm s) + a_f((mathbfu^h_rm fp^h_rm f)(mathbfv^h_rm fq^h_rm f)) + a_fs((mathbfu^h_rm smathbfu^h_rm f p^h_rm f)(mathbfv^h_rm smathbfv^h_rm f q^h_rm f))\nl(mathbfv^h_rm smathbfv^h_rm f q^h_rm f)doteq l_s(mathbfv^h_rm s) + l_f(mathbfv^h_rm f) + l_fGamma_N(mathbfv^h_rm f)\nendaligned","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a((us,uf,p),(vs,vf,q)) = a_s(us,vs) + a_f((uf,p),(vf,q)) + a_fs((us,uf,p),(vs,vf,q))\nl((vs,vf,q)) = l_s(vs) + l_f((vf,q)) + l_f_Γn(vf)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"with the following definitions:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The bilinear form associated with the solid counterpart, a_s(mathbfu^h_rm smathbfv^h_rm s), defined as","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a_s(mathbfumathbfv)=intvarepsilon(mathbfv)boldsymbolsigma_s(epsilon(mathbfu)) dOmega_rm S","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a_s(u,v) = ∫( ε(v) ⊙ (σₛ ∘ ε(u)) )dΩₛ","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The bilinear form associated with the fluid counterpart, a_f((mathbfu^h_rm fp^h_rm f)(mathbfv^h_rm fq^h_rm f)), is defined as","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a_f((mathbfup)(mathbfvq))=intleft(varepsilon(mathbfv)boldsymbolsigma^dev_f(mathbfu) - (nablacdotmathbfv) p + q (nablacdotmathbfu)right) dOmega_rm F","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a_f((u,p),(v,q)) = ∫( ε(v) ⊙ (σ_dev_f ∘ ε(u)) - (∇⋅v)*p + q*(∇⋅u) )dΩ_f","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The bilinear form associated with the coupling between fluid and solid counterparts, a_fs((mathbfu^h_rm smathbfu^h_rm f p^h_rm f)(mathbfv^h_rm smathbfv^h_rm f q^h_rm f)), is given by:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"beginaligned\na_fs((mathbfu_rm smathbfu_rm f p)((mathbfv_rm smathbfv_rm f q))=intleft(gammafracmu_fh(mathbfv_rm f-mathbfv_rm s)cdot(mathbfu_rm f-mathbfu_rm s)right\n-  (mathbfv_rm f-mathbfv_rm s)cdot(mathbfn_rm fscdotboldsymbolsigma^dev_f(mathbfu_rm f))\n+   (mathbfv_rm f-mathbfv_rm S)cdot(p_rm fmathbfn_rm fs)\n-  chi(mathbfn_rm fscdotboldsymbolsigma^dev_f(mathbfv_rm f)cdot(mathbfu^rm f-mathbfu_rm s)\n+ left(q_rm fmathbfn_rm fs)cdot(mathbfu_rm f-mathbfu_rm s) right) dGamma_rm FS\nendaligned","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"a_fs((us,uf,p),(vs,vf,q)) = ∫( α*(jump_Γ(vf,vs)⋅jump_Γ(uf,us)) +\n                               jump_Γ(vf,vs)⋅t_Γfs(1,p,uf,n_Γfs) +\n                               t_Γfs(χ,q,vf,n_Γfs)⋅jump_Γ(uf,us) )dΓ_fs","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Where chi is a parameter that can take values 10 or -10 and it is used to define the symmetric or antisymmetric version of the method, respectively. To difine this form we used the well known Nitsche's method, which enforces the continuity of fluid and solid velocities as well as the continuity of the normal stresses, see for instance [2].","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"const γ = 1.0\nconst χ = -1.0\njump_Γ(wf,ws) = wf.⁺-ws.⁻\nt_Γfs(χ,q,w,n) = q.⁺*n.⁺ - χ*n.⁺⋅(σ_dev_f∘ε(w.⁺))","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"From the interface triangulation we can obtain the interface elements length, h, and the penalty parameter, alpha=gammafracmu_fh, used in the Nitsche's terms.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"using Gridap.CellData\ndim = num_cell_dims(Γ_fs)\nh_Γfs = get_array(∫(1)dΓ_fs)\nα = CellField( lazy_map(h->γ*μ_f/(h.^dim),h_Γfs), Γ_fs)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The linear form associated with the solid counterpart, l_s(mathbfv^h_rm s), is defined as","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_s(mathbfv)=intmathbfvcdot s dOmega_rm S","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_s(v) = ∫( v⋅s )dΩₛ","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The linear form associated with the fluid counterpart, l_f(mathbfv^h_rm f) is defined as","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_f(mathbfvq)=intmathbfvcdot f + qg dOmega_rm F","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_f((v,q)) = ∫( v⋅f + q*g )dΩ_f","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The linear form associated with the fluid Neumann boundary condition, l_fGamma_N(mathbfv^h_rm f), is defined as","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_fGamma_N(mathbfv)=intmathbfvcdot h dGamma_rm N_out","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"l_f_Γn(v) = ∫( v⋅hN )dΓ_out","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The final bilinear and linear forms will be given by","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"algebraic\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Algebraic-System-of-Equations-1","page":"11 Fluid-Structure Interaction","title":"Algebraic System of Equations","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"After defining the weak form of the problem and the integration quadrature rules to perform the numerical integration, we are ready to assemble the linear system of equations. In this case, the system will have the following structure:","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"beginbmatrix\nmathbfA_urm SmathbfA_urm SF0\nmathbfA_urm FSmathbfA_urm FmathbfA_uprm F\n0mathbfA_uprm FmathbfA_prm F\nendbmatrixbeginbmatrix\nmathbfU^h_rm S\nmathbfU^h_rm F\nmathbfP^h_rm F\nendbmatrix = beginbmatrix\nmathbfF^h_urm S\nmathbfF^h_urm F\nmathbfF^h_prm F\nendbmatrix","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"In order to construct the system we define the final FE operator, constructed using the function AffineFEOperator passing as arguments the bilinear and linear forms, a and l, together with the trial and test FE spaces, X and Y.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"op = AffineFEOperator(a,l,X,Y)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Finally, we call solve to obtain the solution vector of nodal values mathbfU^h_rm SmathbfU^h_rm FmathbfP^h_rm F^T","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"uhs, uhf, ph = solve(op)","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"postprocess\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Post-processing-1","page":"11 Fluid-Structure Interaction","title":"Post-processing","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"visualization\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Visualization-1","page":"11 Fluid-Structure Interaction","title":"Visualization","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"The solution fields mathbfU^h_rm SmathbfU^h_rm FmathbfP^h_rm F^T are defined over all the domain, extended with zeros on the inactive part. Calling the function writevtk passing the global triangulation, we will output the global fields.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"writevtk(Ω,\"trian\", cellfields=[\"uhs\" => uhs, \"uhf\" => uhf, \"ph\" => ph])","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"(Image: )","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"However, we can also restrict the fields to the active part by calling the function restrict with the field along with the respective active triangulation.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"writevtk(Ω_s,\"trian_solid\",cellfields=[\"uhs\"=>uhs])\nwritevtk(Ω_f,\"trian_fluid\",cellfields=[\"ph\"=>ph,\"uhf\"=>uhf])","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"(Image: )","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"<a name=\"QOIs\"></a>","category":"page"},{"location":"pages/t011_fsi_tutorial/#Quantities-of-Interest-1","page":"11 Fluid-Structure Interaction","title":"Quantities of Interest","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"Γ_S = BoundaryTriangulation(model,tags=[\"cylinder\",\"interface\"])\ndΓₛ = Measure(Γ_S,bdegree)\nn_ΓS = get_normal_vector(Γ_S)\nFD, FL = sum( ∫( (n_ΓS⋅σ_dev_f(ε(uhf))) - ph*n_ΓS )*dΓₛ )\nprintln(\"Drag force: \", FD)\nprintln(\"Lift force: \", FL)","category":"page"},{"location":"pages/t011_fsi_tutorial/#References-1","page":"11 Fluid-Structure Interaction","title":"References","text":"","category":"section"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"[1] Turek, S., Hron, J., Madlik, M., Razzaq, M., Wobker, H., & Acker, J. F. (2011).* Numerical simulation and benchmarking of a monolithic multigrid solver for fluid-structure interaction problems with application to hemodynamics. In Fluid Structure Interaction II (pp. 193-220). Springer, Berlin, Heidelberg.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"[2] Burman, E., and Fernández, M. A. Stabilized explicit coupling for fluid–structure interaction using Nitsche's method. Comptes Rendus Mathematique 345.8 (2007): 467-472.","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"","category":"page"},{"location":"pages/t011_fsi_tutorial/#","page":"11 Fluid-Structure Interaction","title":"11 Fluid-Structure Interaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/p_laplacian.jl\"","category":"page"},{"location":"pages/t004_p_laplacian/#Tutorial-4:-p-Laplacian-1","page":"4 p-Laplacian","title":"Tutorial 4: p-Laplacian","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"How to solve a simple nonlinear PDE in Gridap\nHow to define the weak residual and its Jacobian\nHow to setup and use a nonlinear solver\nHow to define new boundaries from a given discrete model","category":"page"},{"location":"pages/t004_p_laplacian/#Problem-statement-1","page":"4 p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the p-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field u such that","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f textin Omega\nu = 0  texton  Gamma_0\nu = g  texton  Gamma_g\nleft( nabla u^p-2 nabla u right)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"with p2. The computational domain Omega is the one depicted in next figure, which is the same as in the first tutorial. However, we slightly change the boundary conditions here. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on Gamma_0 and Gamma_rm N  respectively, and in-homogeneous Dirichlet conditions on Gamma_g. The Dirichlet boundaries Gamma_0 and Gamma_g are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is Gamma_rm NdoteqpartialOmega setminus (Gamma_0cupGamma_g). In this example, we consider the values p=3, f=1, and g=2.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t004_p_laplacian/#Numerical-scheme-1","page":"4 p-Laplacian","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find uin U_g such that r(u)(v) = 0 for all vin V_0. As in previous tutorials, the space U_g is the set of functions in H^1(Omega) that fulfill the Dirichlet boundary conditions, whereas V_0 is composed by functions in H^1(Omega) that vanish at the Dirichlet boundary. The weak residual r(u) evaluated at a function  uin U_g is the linear form defined as","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"r(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction delta uin V_0, namely r(u+delta u)(v)approx r(u)(v) + j(u)(delta uv). In previous formula,  j(u) is the Jacobian evaluated at uin U_g, which is the bilinear form","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"j(u)(delta uv) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual r and the Jacobian j. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.","category":"page"},{"location":"pages/t004_p_laplacian/#Discrete-model-1","page":"4 p-Laplacian","title":"Discrete model","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using Gridap\nmodel = DiscreteModelFromFile(\"../models/model.json\")","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"As stated before, we want to impose Dirichlet boundary conditions on Gamma_0 and Gamma_g,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"and by opening the file \"model_0\" in Paraview that the boundary identified as \"sides\" only includes the vertices in the interior of Gamma_0, but here we want to impose Dirichlet boundary conditions in the closure of Gamma_0, i.e., also on the vertices on the contour of Gamma_0. Fortunately, the objects on the contour of Gamma_0 are identified  with the tag \"sides_c\" (see next figure). Thus, the Dirichlet boundary Gamma_0 can be built as the union of the objects identified as \"sides\" and \"sides_c\".","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Gridap provides a convenient way to create new object identifiers (referred to as \"tags\") from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as FaceLabeling):","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"labels = get_face_labeling(model)","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Then, we can add new identifiers (aka \"tags\") to it. In the next line, we create a new tag called \"diri0\" as the union of the objects identified as \"sides\" and \"sides_c\", which is precisely what we need to represent the closure of the Dirichlet boundary Gamma_0.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"diri0\",[\"sides\", \"sides_c\"])","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We follow the same approach to build a new identifier for the closure of the Dirichlet boundary Gamma_g. In this case, the boundary is expressed as the union of the objects identified with the tags \"circle\", \"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\". Thus, we create a new tag for  Gamma_g, called \"dirig\" simply as follows:","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"dirig\",\n  [\"circle\",\"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\"])","category":"page"},{"location":"pages/t004_p_laplacian/#FE-Space-1","page":"4 p-Laplacian","title":"FE Space","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Now, we can build the FE space by using the newly defined boundary tags.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"reffe = ReferenceFE(lagrangian,Float64,1)\nV0 = TestFESpace(model,reffe,conformity=:H1,labels=labels,dirichlet_tags=[\"diri0\", \"dirig\"])","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the labels object (that contains the newly created boundary tags). From this FE space, we define the trial FE spaces","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"g = 1\nUg = TrialFESpace(V0,[0,g])","category":"page"},{"location":"pages/t004_p_laplacian/#Nonlinear-FE-problem-1","page":"4 p-Laplacian","title":"Nonlinear FE problem","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. We first need to define the usual objects for numerical integration:","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"degree=2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"On the one hand, the weak residual is built as follows","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LinearAlgebra: norm\nconst p = 3\nflux(∇u) = norm(∇u)^(p-2) * ∇u\nf(x) = 1\nres(u,v) = ∫( ∇(v)⊙(flux∘∇(u)) - v*f )*dΩ","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Function res is the one representing the integrand of the weak residual r(u)(v). The first argument of function res stands for the function uin U_g, where the residual is evaluated, and the second argument stands for a generic test function vin V_0.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"On the other hand,  we (optionally) implement a function jac representing the Jacobian.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"dflux(∇du,∇u) = (p-2)*norm(∇u)^(p-4)*(∇u⊙∇du)*∇u+norm(∇u)^(p-2)*∇du\njac(u,du,v) = ∫( ∇(v)⊙(dflux∘(∇(du),∇(u))) )*dΩ","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The first argument of function jac stands for function uin U_g, where the Jacobian is evaluated. The second argument is a test function vin V_0, and the third argument represents an arbitrary direction delta u in V_0.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We finally construct the nonlinear FE problem","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"op = FEOperator(res,jac,Ug,V0)","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Here, we have constructed an instance of FEOperator, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the functions representing the weak residual and Jacobian, and the test and trial spaces. If only the function for the residual is provided, the Jacobian is computed internally with automatic differentiation.","category":"page"},{"location":"pages/t004_p_laplacian/#Nonlinear-solver-phase-1","page":"4 p-Laplacian","title":"Nonlinear solver phase","text":"","category":"section"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type FESolver.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We construct an instance of FESolver as follows:","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LineSearches: BackTracking\nnls = NLSolver(\n  show_trace=true, method=:newton, linesearch=BackTracking())\nsolver = FESolver(nls)","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the NLSolver function used above internally calls the nlsolve function of the NLsolve package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function nlsolve to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the LineSearches package.","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We are finally in place to solve the nonlinear FE problem. The initial guess is a FEFunction, which we build from a vector of random (free) nodal values:","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"import Random\nRandom.seed!(1234)\nx = rand(Float64,num_free_dofs(Ug))\nuh0 = FEFunction(Ug,x)\nuh, = solve!(uh0,solver,op)","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We finish this tutorial by writing the computed solution for visualization (see next figure).","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(Ω,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"","category":"page"},{"location":"pages/t004_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/poisson_transient.jl\"","category":"page"},{"location":"pages/t017_poisson_transient/#Tutorial-17:-Transient-Poisson-equation-1","page":"17 Transient Poisson equation","title":"Tutorial 17: Transient Poisson equation","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t017_poisson_transient/#Introduction-1","page":"17 Transient Poisson equation","title":"Introduction","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"In this tutorial we will learn how to use GridapODEs.jl for approximating transient PDEs by using time marching schemes (method of lines). We consider the heat equation, a.k.a. the transient Poisson equation.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"We will focus on the time discretization on the equations, assuming that the reader is familiar with the Gridap API for spatial finite element discretizations. See, e.g., tutorial 1 for more details.","category":"page"},{"location":"pages/t017_poisson_transient/#Problem-statement-1","page":"17 Transient Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"We solve the heat equation in a 2-dimensional domain Omega, the unit square, with Homogenous Dirichlet boundaries on the whole boundary partial Omega. We consider a time-dependent conductivity kappa(t)=10 + 095sin(2pi t), a time-dependent volumetric forcing term f(t) = sin(pi t) and a constant Homogenous boundary condition g = 00. The initial solution is u(x0) = u_0 = 0. With these definitions, the strong form of the problem reads:","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"leftlbrace\nbeginaligned\nfracpartial u(t)partial t -kappa(t)Delta u(t) = f(t)   textin  Omega\nu(t) = 0  texton Gamma_rm D\nu(0) = 0  textin Omega\nendaligned\nright","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"The weak form of the problem reads: find u(t)in U_g(t) such that","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"m(tuv) + a(tuv) = b(tv)quad forall vin  V","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Note that U_g(t) is a transient FE space, in the sense that Dirichlet boundary value of functions in U_g can change in time (even though this is not the case in this tutorial). The definition of m(uv), a(uv) and b(v) is as follows:","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"beginaligned\nm(tuv) = int_Omega vfracpartial upartial t dOmega \na(tuv) = int_Omega kappa(t) nabla vcdot nabla u dOmega \nb(tv) = int_Omega v f(t) dOmega\nendaligned","category":"page"},{"location":"pages/t017_poisson_transient/#Discrete-model-and-Triangulation-1","page":"17 Transient Poisson equation","title":"Discrete model and Triangulation","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"As usual, let us first load Gridap.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"using Gridap","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"First, we define the DiscreteModel and the Triangulation. More details on this can be found in tutorial 2.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"𝒯 = CartesianDiscreteModel((0,1,0,1),(20,20))\nΩ = Interior(𝒯)\ndΩ = Measure(Ω,2)","category":"page"},{"location":"pages/t017_poisson_transient/#FE-space-1","page":"17 Transient Poisson equation","title":"FE space","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"In this tutorial we will use linear Lagrangian Finite Elements.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"refFE = ReferenceFE(lagrangian,Float64,1)","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"The space of test functions is constant in time and is defined in steady problems:","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"V = TestFESpace(𝒯,refFE,dirichlet_tags=\"boundary\")","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"The trial space is now a TransientTrialFESpace, wich is constructed from a TestFESpace and a function (or vector of functions) for the Dirichlet boundary condition/s. In that case, the boundary condition function is a time-independent constant, but it could also be a time-dependent field depending on the coordinates x and time t.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"g(x,t::Real) = 0.0\ng(t::Real) = x -> g(x,t)\nU = TransientTrialFESpace(V,g)","category":"page"},{"location":"pages/t017_poisson_transient/#Weak-form-1","page":"17 Transient Poisson equation","title":"Weak form","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"The weak form of the problem follows the same structure as other Gridap tutorials, where we define the bilinear and linear forms to define the FEOperator. In this case we need to deal with time-dependent quantities and with the presence of time derivatives. The former is handled by passing the time, t, as an additional argument to the form, i.e. a(tuv). The latter is defined using the time derivative operator ∂t.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"The most general way of constructing a transient FE operator is by using the TransientFEOperator function, which receives a residual, a jacobian with respect to the unknown and a jacobian with respect to the time derivative.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"κ(t) = 1.0 + 0.95*sin(2π*t)\nf(t) = sin(π*t)\nres(t,u,v) = ∫( ∂t(u)*v + κ(t)*(∇(u)⋅∇(v)) - f(t)*v )dΩ\njac(t,u,du,v) = ∫( κ(t)*(∇(du)⋅∇(v)) )dΩ\njac_t(t,u,duₜ,v) = ∫( duₜ*v )dΩ\nop = TransientFEOperator(res,jac,jac_t,U,V)","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"We can also take advantage of automatic differentiation techniques to compute both Jacobians and use the TransientFEOperator function sending just the residual.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"op_AD = TransientFEOperator(res,U,V)","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Alternatively, we can exploit the fact that the problem is linear and use the transient Affine FE operator signature TransientAffineFEOperator. In that case, we send a form for the mass contribution, m, a form for the stiffness contribution, a, and the forcing term, b.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"m(t,u,v) = ∫( u*v )dΩ\na(t,u,v) = ∫( κ(t)*(∇(u)⋅∇(v)) )dΩ\nb(t,v) = ∫( f(t)*v )dΩ\nop_Af = TransientAffineFEOperator(m,a,b,U,V)","category":"page"},{"location":"pages/t017_poisson_transient/#Alternative-FE-operator-definitions-1","page":"17 Transient Poisson equation","title":"Alternative FE operator definitions","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"For time-dependent problems with constant coefficients, which is not the case of this tutorial, one could use the optimized operator TransientConstantMatrixFEOperator, which assumes that the matrix contributions (m and a) are time-independent. That is:","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"m₀(u,v) = ∫( u*v )dΩ\na₀(u,v) = ∫( κ(0.0)*(∇(u)⋅∇(v)) )dΩ\nop_CM = TransientConstantMatrixFEOperator(m,a,b,U,V)","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Going further, if we had a problem with constant forcing term, i.e. constant force and constant boundary conditions, we could have used the TransientConstantFEOperator. In that case the linear form is also time-independent.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"b₀(v) = ∫( f(0.0)*v )dΩ\nop_C = TransientConstantFEOperator(m,a,b,U,V)","category":"page"},{"location":"pages/t017_poisson_transient/#Transient-solver-1","page":"17 Transient Poisson equation","title":"Transient solver","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Once we have the FE operator defined, we proceed with the definition of the transient solver. First, we define a linear solver to be used at each time step. Here we use the LUSolver, but other choices are possible.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"linear_solver = LUSolver()","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Then, we define the ODE solver. That is, the scheme that will be used for the time integration. In this tutorial we use the ThetaMethod with theta = 05, resulting in a 2nd order scheme. The ThetaMethod function receives the linear solver, the time step size Delta t (constant) and the value of \\theta $.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Δt = 0.05\nθ = 0.5\node_solver = ThetaMethod(linear_solver,Δt,θ)","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"Finally, we define the solution using the solve function, giving the ODE solver, the FE operator, an initial solution, an initial time and a final time. To construct the initial condition we interpolate the initial value (in that case a constant value of 0.0) into the FE space U(t) at t=00.","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"u₀ = interpolate_everywhere(0.0,U(0.0))\nt₀ = 0.0\nT = 10.0\nuₕₜ = solve(ode_solver,op,u₀,t₀,T)","category":"page"},{"location":"pages/t017_poisson_transient/#Postprocessing-1","page":"17 Transient Poisson equation","title":"Postprocessing","text":"","category":"section"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"We should highlight that uₕₜ is just an iterable function and the results at each time steps are only computed when iterating over it, i.e., lazily. We can post-process the results and generate the corresponding vtk files using the createpvd and createvtk functions. The former will create a .pvd file with the collection of .vtu files saved at each time step by createvtk. The computation of the problem solutions will be triggered in the following loop:","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"createpvd(\"poisson_transient_solution\") do pvd\n  for (uₕ,t) in uₕₜ\n    pvd[t] = createvtk(Ω,\"poisson_transient_solution_$t\"*\".vtu\",cellfields=[\"u\"=>uₕ])\n  end\nend","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"","category":"page"},{"location":"pages/t017_poisson_transient/#","page":"17 Transient Poisson equation","title":"17 Transient Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/inc_navier_stokes.jl\"","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Tutorial-8:-Incompressible-Navier-Stokes-1","page":"8 Incompressible Navier-Stokes","title":"Tutorial 8: Incompressible Navier-Stokes","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"How to solve nonlinear multi-field PDEs in Gridap\nHow to build FE spaces whose functions have zero mean value","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Problem-statement-1","page":"8 Incompressible Navier-Stokes","title":"Problem statement","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The goal of this last tutorial is to solve a nonlinear multi-field PDE. As a model problem, we consider a well known benchmark in computational fluid dynamics, the lid-driven cavity for the incompressible Navier-Stokes equations. Formally, the PDE we want to solve is: find the velocity vector u and the pressure p such that","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"leftlbrace\nbeginaligned\n-Delta u + mathitRe (ucdot nabla) u + nabla p = 0 text in Omega\nnablacdot u = 0 text in  Omega\nu = g text on  partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"where the computational domain is the unit square Omega doteq (01)^d, d=2, mathitRe is the Reynolds number (here, we take mathitRe=10), and (w cdot nabla) u = (nabla u)^t w  is the well known convection operator. In this example, the driving force is the Dirichlet boundary velocity g, which is a non-zero horizontal velocity with a value of g = (10)^t on the top side of the cavity, namely the boundary (01)times1, and g=0 elsewhere on partialOmega. Since we impose Dirichlet boundary conditions on the entire boundary partialOmega, the mean value of the pressure is constrained to zero in order have a well posed problem,","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"int_Omega q  rm dOmega = 0","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Numerical-Scheme-1","page":"8 Incompressible Navier-Stokes","title":"Numerical Scheme","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"In order to approximate this problem we chose a formulation based on inf-sub stable Q_kP_k-1 elements with continuous velocities and discontinuous pressures (see, e.g., [1] for specific details). The interpolation spaces are defined as follows.  The velocity interpolation space is","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"V doteq  v in C^0(Omega)^d v_Tin Q_k(T)^d text for all  TinmathcalT ","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"where T denotes an arbitrary cell of the FE mesh mathcalT, and Q_k(T) is the local polynomial space in cell T defined as the multi-variate polynomials in T of order less or equal to k in each spatial coordinate. Note that, this is the usual continuous vector-valued Lagrangian FE space of order k defined on a mesh of quadrilaterals or hexahedra.  On the other hand, the space for the pressure is","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"beginaligned\nQ_0 doteq  q in Q   int_Omega q  rm dOmega = 0 text with\nQ doteq  q in L^2(Omega) q_Tin P_k-1(T) text for all  TinmathcalT\nendaligned","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"where P_k-1(T) is the polynomial space of multi-variate polynomials in T of degree less or equal to k-1. Note that functions in Q_0 are strongly constrained to have zero mean value. This is achieved in the code by removing one degree of freedom from the (unconstrained) interpolation space Q and  adding a constant to the computed pressure so that the resulting function has zero mean value.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The weak form associated to these interpolation spaces reads: find (up)in U_g times Q_0 such that r(up)(vq)=0 for all (vq)in V_0 times Q_0 where U_g and V_0 are the set of functions in V fulfilling the Dirichlet boundary condition g and 0  on partialOmega respectively. The weak residual r evaluated at a given pair (up) is the linear form defined as","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"r(up)(vq) doteq a((up)(vq))+ c(u)(v)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"with","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"beginaligned\na((up)(vq)) doteq int_Omega nabla v cdot nabla u  rm dOmega - int_Omega (nablacdot v)  p  rm dOmega + int_Omega q  (nabla cdot u)  rm dOmega\nc(u)(v) doteq int_Omega v \tcdot left( (ucdotnabla) u right) rm dOmega\nendaligned","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"Note that the bilinear form a is associated with the linear part of the PDE, whereas c is the contribution to the residual resulting from the convective term.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"In order to solve this nonlinear weak equation with a Newton-Raphson method, one needs to compute the Jacobian associated with the residual r. In this case, the Jacobian j evaluated at a pair (up) is the bilinear form defined as","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"j(up)((delta u delta p)(vq)) doteq a((delta udelta p)(vq))  + rm dc(u)(delta uv)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"where rm dc results from the linearization of the convective term, namely","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"rm dc(u)(delta uv) doteq int_Omega v cdot left( (ucdotnabla) delta u right)  rm dOmega + int_Omega v cdot left( (delta ucdotnabla) u right)   rm dOmega","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The implementation of this numerical scheme is done in Gridap by combining the concepts previously seen for single-field nonlinear PDEs  and linear multi-field problems.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Discrete-model-1","page":"8 Incompressible Navier-Stokes","title":"Discrete model","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"We start with the discretization of the computational domain. We consider a 100times100 Cartesian mesh of the unit square.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"using Gridap\nn = 100\ndomain = (0,1,0,1)\npartition = (n,n)\nmodel = CartesianDiscreteModel(domain,partition)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"For convenience, we create two new boundary tags,  namely \"diri1\" and \"diri0\", one for the top side of the square (where the velocity is non-zero), and another for the rest of the boundary (where the velocity is zero).","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"labels = get_face_labeling(model)\nadd_tag_from_tags!(labels,\"diri1\",[6,])\nadd_tag_from_tags!(labels,\"diri0\",[1,2,3,4,5,7,8])","category":"page"},{"location":"pages/t008_inc_navier_stokes/#FE-spaces-1","page":"8 Incompressible Navier-Stokes","title":"FE spaces","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"For the velocities, we need to create a conventional vector-valued continuous Lagrangian FE space. In this example, we select a second order interpolation.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"D = 2\norder = 2\nreffeᵤ = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\nV = TestFESpace(model,reffeᵤ,conformity=:H1,labels=labels,dirichlet_tags=[\"diri0\",\"diri1\"])","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The interpolation space for the pressure is built as follows","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"reffeₚ = ReferenceFE(lagrangian,Float64,order-1;space=:P)\nQ = TestFESpace(model,reffeₚ,conformity=:L2,constraint=:zeromean)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"With the options :Lagrangian, space=:P, valuetype=Float64, and order=order-1, we select the local polynomial space P_k-1(T) on the cells TinmathcalT. With the symbol space=:P we specifically chose a local Lagrangian interpolation of type \"P\". Without using space=:P, would lead to a local Lagrangian of type \"Q\" since this is the default for quadrilateral or hexahedral elements. On the other hand, constraint=:zeromean leads to a FE space, whose functions are constrained to have mean value equal to zero, which is just what we need for the pressure space. With these objects, we build the trial multi-field FE spaces","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"uD0 = VectorValue(0,0)\nuD1 = VectorValue(1,0)\nU = TrialFESpace(V,[uD0,uD1])\nP = TrialFESpace(Q)\n\nY = MultiFieldFESpace([V, Q])\nX = MultiFieldFESpace([U, P])","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Triangulation-and-integration-quadrature-1","page":"8 Incompressible Navier-Stokes","title":"Triangulation and integration quadrature","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"From the discrete model we can define the triangulation and integration measure","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"degree = order\nΩₕ = Triangulation(model)\ndΩ = Measure(Ωₕ,degree)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Nonlinear-weak-form-1","page":"8 Incompressible Navier-Stokes","title":"Nonlinear weak form","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The different terms of the nonlinear weak form for this example are defined following an approach similar to the one discussed for the p-Laplacian equation, but this time using the notation for multi-field problems.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"const Re = 10.0\nconv(u,∇u) = Re*(∇u')⋅u\ndconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The bilinear form reads","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"a((u,p),(v,q)) = ∫( ∇(v)⊙∇(u) - (∇⋅v)*p + q*(∇⋅u) )dΩ","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"The nonlinear term and its Jacobian are given by","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"c(u,v) = ∫( v⊙(conv∘(u,∇(u))) )dΩ\ndc(u,du,v) = ∫( v⊙(dconv∘(du,∇(du),u,∇(u))) )dΩ","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"Finally, the Navier-Stokes weak form residual and Jacobian can be defined as","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"res((u,p),(v,q)) = a((u,p),(v,q)) + c(u,v)\njac((u,p),(du,dp),(v,q)) = a((du,dp),(v,q)) + dc(u,du,v)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"With the functions res, and jac representing the weak residual and the Jacobian, we build the nonlinear FE problem:","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"op = FEOperator(res,jac,X,Y)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#Nonlinear-solver-phase-1","page":"8 Incompressible Navier-Stokes","title":"Nonlinear solver phase","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"To finally solve the problem, we consider the same nonlinear solver as previously considered for the  p-Laplacian equation.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"using LineSearches: BackTracking\nnls = NLSolver(\n  show_trace=true, method=:newton, linesearch=BackTracking())\nsolver = FESolver(nls)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"In this example, we solve the problem without providing an initial guess (a default one equal to zero will be generated internally)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"uh, ph = solve(solver,op)","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"Finally, we write the results for visualization (see next figure).","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"writevtk(Ωₕ,\"ins-results\",cellfields=[\"uh\"=>uh,\"ph\"=>ph])","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"(Image: )","category":"page"},{"location":"pages/t008_inc_navier_stokes/#References-1","page":"8 Incompressible Navier-Stokes","title":"References","text":"","category":"section"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"[1] H. C. Elman, D. J. Silvester, and A. J. Wathen. Finite elements and fast iterative solvers: with applications in incompressible fluid dynamics. Oxford University Press, 2005.","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"","category":"page"},{"location":"pages/t008_inc_navier_stokes/#","page":"8 Incompressible Navier-Stokes","title":"8 Incompressible Navier-Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/poisson.jl\"","category":"page"},{"location":"pages/t001_poisson/#Tutorial-1:-Poisson-equation-1","page":"1 Poisson equation","title":"Tutorial 1: Poisson equation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"How to solve a simple PDE in Julia with Gridap\nHow to load a discrete model (aka a FE mesh) from a file\nHow to build a conforming Lagrangian FE space\nHow to define the different terms in a weak form\nHow to impose Dirichlet and Neumann boundary conditions\nHow to visualize results","category":"page"},{"location":"pages/t001_poisson/#Problem-statement-1","page":"1 Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.  We want to solve the Poisson equation on the 3D domain depicted in next figure with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on Gamma_rm D, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries Gamma_rm G, Gamma_rm Y, and Gamma_rm B (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in Gamma_rm W, the remaining portion of the boundary (marked in white).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Formally, the problem to solve is: find the scalar field u such that","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"being n the outwards unit normal vector to the Neumann boundary Gamma_rm N doteq Gamma_rm GcupGamma_rm YcupGamma_rm BcupGamma_rm W. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3 on Gamma_rm GcupGamma_rm YcupGamma_rm B and h(x)=0 on Gamma_rm W. The variable x is the position vector x=(x_1x_2x_3).","category":"page"},{"location":"pages/t001_poisson/#Numerical-scheme-1","page":"1 Poisson equation","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation). The weak form associated with this formulation is: find uin U_g such that $ a(u,v) = b(v) $ for all vin V_0, where U_g and V_0 are the subset of functions in H^1(Omega) that fulfill the Dirichlet boundary condition g and 0 respectively. The bilinear and linear forms for this problems are","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v h  rm dGamma_rm N","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The problem is solved numerically by approximating the spaces U_g and V_0 by their discrete counterparts associated with a FE mesh of the computational domain Omega. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.","category":"page"},{"location":"pages/t001_poisson/#Setup-1","page":"1 Poisson equation","title":"Setup","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The step number 0 in order to solve the problem is to load the Gridap library in the code. If you have configured your Julia environment properly, it is simply done with the line:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap","category":"page"},{"location":"pages/t001_poisson/#Discrete-model-1","page":"1 Poisson equation","title":"Discrete model","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"As in any FE simulation, we need a discretization of the computational domain (i.e., a FE mesh). All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type DiscreteModel. In the following line, we build an instance of DiscreteModel by loading a json file.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"model = DiscreteModelFromFile(\"../models/model.json\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The file \"model.json\" is a regular json file that includes a set of fields that describe the discrete model. It was generated by using together the GMSH mesh generator and the GridapGmsh package. First, we generate a \"model.msh\" file with GMSH (which contains a FE mesh and information about user-defined physical boundaries in {GMSH} format). Then, this file is converted to the Gridap-compatible \"model.json\" file using the conversion tools available in the GridapGmsh package. See the documentation of the GridapGmsh for more information.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"You can easily inspect the generated discrete model in Paraview by writing it in vtk format.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The previous line generates four different files model_0.vtu, model_1.vtu, model_2.vtu, and model_3.vtu containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"For instance, if you want to see which faces of the model are on the boundary Gamma_rm B (i.e., the walls of the circular perforation), open the file model_2.vtu and chose coloring by the element field \"circle\". You should see that only the faces on the circular hole have a value different from zero (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"It is also possible to see which vertices are on the Dirichlet boundary Gamma_rm D. To do so, open the file model_0.vtu and chose coloring by the field \"sides\" (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"That is, the boundary Gamma_rm B (i.e., the walls of the circular hole) is called \"circle\" and the Dirichlet boundary Gamma_rm D is called \"sides\" in the model. In addition, the walls of the triangular hole Gamma_rm G and the walls of the square hole Gamma_rm Y are identified in the model with the names \"triangle\" and \"square\" respectively. You can easily check this by opening the corresponding file in Paraview.","category":"page"},{"location":"pages/t001_poisson/#FE-spaces-1","page":"1 Poisson equation","title":"FE spaces","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces V_0 and U_g (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of V_0 as the standard Conforming Lagrangian FE space (with zero boundary conditions) associated with the discretization of the computational domain. The approximation of the FE space V_0 is built as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV0 = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=\"sides\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we have used the TestFESpace constructor, which constructs a particular FE space (to be used as a test space) from a set of options described as positional and key-word arguments. The first positional argument is the model on top of which we want to build the space. The second positional argument contains information about the type of FE interpolation (the reference FE in this case). With ReferenceFE(lagrangian,Float64,order) We select a scalar-valued Lagrangian reference FE of order 1, where the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument conformity we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use conformity=:H1, which means that the resulting interpolation space is a subset of H^1(Omega) (i.e., continuous shape functions). On the other hand, we pass the identifiers of the Dirichlet boundary via the dirichlet_tags argument. In this case, we mark as Dirichlet all objects of the discrete model identified with the \"sides\" tag. Since this is a test space, the corresponding shape functions vanishes at the Dirichlet boundary.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once the space V_0 is discretized in the code, we proceed with the approximation of the trial space U_g.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"g(x) = 2.0\nUg = TrialFESpace(V0,g)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"To this end, we have used the TrialFESpace constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space.","category":"page"},{"location":"pages/t001_poisson/#Numerical-integration-1","page":"1 Poisson equation","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain Omega and on the Neumann boundary Gamma_rm N. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a triangulation of the integration domain), plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type Triangulation. For integrating on the domain Omega, we build the following triangulation and the corresponding Lebesgue measure, which will allow to write down integrals in a syntax similar to the usual mathematical notation.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"degree = 2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we build a triangulation from the cells of the model and build (an approximation of) the Lebesgue measure using a quadrature rule of degree 2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"On the other hand, we need a special type of triangulation, represented by the type BoundaryTriangulation, to integrate on the boundary. Essentially, a BoundaryTriangulation is a particular type of Triangulation that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"neumanntags = [\"circle\", \"triangle\", \"square\"]\nΓ = BoundaryTriangulation(model,tags=neumanntags)\ndΓ = Measure(Γ,degree)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#Weak-form-1","page":"1 Poisson equation","title":"Weak form","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"With all the ingredients presented so far, we are ready to define the weak form. This is done by defining to functions representing the bi-linear and linear forms:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"f(x) = 1.0\nh(x) = 3.0\na(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ\nb(v) = ∫( v*f )*dΩ + ∫( v*h )*dΓ","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that by using the integral function ∫, the Lebesgue measures dΩ, dΓ, and the gradient function ∇, the weak form is written with an obvious relation with the corresponding mathematical notation.","category":"page"},{"location":"pages/t001_poisson/#FE-Problem-1","page":"1 Poisson equation","title":"FE Problem","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type FEOperator (both for linear and nonlinear cases). Since we want to solve a linear problem, we use the concrete type AffineFEOperator, i.e., a problem represented by a matrix and a right hand side vector.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"op = AffineFEOperator(a,b,Ug,V0)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that the AffineFEOperator object representing our FE problem is built from the function a and b representing the weak form and test and trial FE spaces V0 and Ug.","category":"page"},{"location":"pages/t001_poisson/#Solver-phase-1","page":"1 Poisson equation","title":"Solver phase","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type FESolver. Since this is a linear problem, we use a LinearFESolver:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"ls = LUSolver()\nsolver = LinearFESolver(ls)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"LinearFESolver objects are built from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"uh = solve(solver,op)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The solve function returns the computed numerical solution uh. This object is an instance of FEFunction, the type used to represent a function in a FE space. We can inspect the result by writing it into a vtk file:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(Ω,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"which will generate a file named results.vtu having a nodal field named \"uh\" containing the solution of our problem (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#References-1","page":"1 Poisson equation","title":"References","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/unfitted_poisson.jl\"","category":"page"},{"location":"pages/t019_unfitted_poisson/#Tutorial-19:-Unfitted-Poisson-1","page":"19 Unfitted Poisson","title":"Tutorial 19: Unfitted Poisson","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"How to use GridapEmbedded\nHow to formulate an unfitted finite element method\nHow to construct an unfitted boundary geometry setup\nHow to use the Aggregated Finite Element Method\nHow to impose Dirichlet boundary conditions weakly","category":"page"},{"location":"pages/t019_unfitted_poisson/#Problem-statement-1","page":"19 Unfitted Poisson","title":"Problem statement","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We want to solve the Poisson equation on the crescent moon 2D shape shown in the next figure","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig0a)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We prescribe the linear solution to the problem u(x) = x - y and Dirichlet boundary conditions on the whole boundary. Thus, the problem to solve is: find the scalar field u such that","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"leftlbrace\nbeginaligned\n-Delta u = 0  textin  Omega\nu = x - y  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t019_unfitted_poisson/#Numerical-scheme-1","page":"19 Unfitted Poisson","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"To solve this PDE, we will use an unfitted technique. The idea behind unfitted, aka embedded or immersed boundary, methods is quite simple: Instead of relying on a mesh that fits to the domain boundary, we embed the domain in a background grid, upon which we will define our finite elements.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Body-fitted Unfitted\n(Image: fig0b) (Image: fig0c)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Unfitted methods allow one to circumvent the meshing bottleneck when dealing with very complex geometries. But, as usual, this comes at a price. In unfitted methods, integration of the weak form and imposition of Dirichlet boundary conditions becomes more involved. In addition, we have to be careful with the small cut cell problem, which refers to stability and ill-conditioning issues that appear in presence of very small intersections between the background cells and the domain.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Fortunately, there are plenty of solutions available to take care of all these challenges. For more details, we refer to this recent review:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"F. de Prenter, C. Verhoosel, H. van Brummelen, M. Larson, S. Badia, Stability and conditioning of immersed finite element methods: analysis and remedies arXiv preprint arXiv:2208.08538","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In this tutorial, we will use the functionality available at GridapEmbedded to formulate and solve the unfitted problem above. We will illustrate a typical unfitted FE simulation pipeline in GridapEmbedded, including how we setup the embedded geometry, how we deal with the integration of the weak form and the imposition of Dirichlet boundary conditions.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We will discretise the problem with the aggregated finite element method, which is robust to the small cut cell problem. For more details, we refer to:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"S. Badia, A.F. Martín, F. Verdugo, The aggregated unfitted finite element method for elliptic problems, Computer Methods in Applied Mechanics and Engineering 336 (2018), 533-553.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We recommend to read both references above to grasp the details of this tutorial.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"The first step is to load the Gridap and GridapEmbedded packages.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"using Gridap\nusing GridapEmbedded","category":"page"},{"location":"pages/t019_unfitted_poisson/#Implicit-boundary-representation-1","page":"19 Unfitted Poisson","title":"Implicit boundary representation","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"The next step is to generate the embedded geometry. The most straightforward way to represent the geometry is with the level-set method. It amounts to represent a closed curve (2D) or surface (3D) Gamma using an auxiliary function psi, called the level-set function. Gamma is represented as the zero-level-set of psi by","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Gamma =  (xy)    psi(xy) = 0 ","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"and the level-set method manipulates Gamma implicitly, through the function psi. This function psi is assumed to take negative values inside the region delimited by Gamma and positive values outside.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"GridapEmbedded offers out-of-the-box level set surface descriptions for the disk, cylinder, sphere, square, tube, among others. You can also implement your own level-set function.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Interestingly, you can also construct complex domains from simple level-set descriptions. This is done by translating Boolean set operations and geometric transformations into simple manipulations of the level-set functions. For instance, given two level-set functions psi_1 and psi_2, representing the domains Omega_1 and Omega_2, the level-set function psi = min(psi_1psi_2) gives the domain Omega_1 cup Omega_2.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We will use the former properties to generate the crescent moon shape with GridapEmbedded as follows. First, we note that the crescent moon shape is the outcome of subtracting to a disk of radius R=12 another disk of radius R, whose center is at a relative position (-R2R2).","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig1)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Defining this geometry in GridapEmbedded is done as follows:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"R  = 0.5\nL  = 0.5*R\np1 = Point(0.0,0.0)\np2 = p1 + VectorValue(-L,L)\n\ngeo1 = disk(R,x0=p1)\ngeo2 = disk(R,x0=p2)\ngeo3 = setdiff(geo1,geo2)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Where we have used the setdiff function to subtract the disk geo2 to the disk geo1. This is a very simple example of constructive solid geometry. GridapEmbedded allows to create more complex CSG geometries as shown here. For more general shapes, GridapEmbedded admits an STL description of the implicit geometry, see package STLCutters for more details.","category":"page"},{"location":"pages/t019_unfitted_poisson/#Unfitted-triangulations-1","page":"19 Unfitted Poisson","title":"Unfitted triangulations","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"As explained, the rationale of unfitted methods is to embed the domain of interest in a background Cartesian grid (or, more generally, any easy-to-generate mesh). In our case, we generate a 30x30 Cartesian grid model containing the geometry as","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"t = 1.01\npmin = p1-t*R\npmax = p1+t*R\n\nn = 30\npartition = (n,n)\nbgmodel = CartesianDiscreteModel(pmin,pmax,partition)\ndp = pmax - pmin","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Unfitted FE formulations in GridapEmbedded hang on two different type of triangulations: \"Active\" and \"Physical\". In order to generate them, we need first to cut the embedded geometry against the model with the function cut.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"cutgeo = cut(bgmodel,geo3)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"cut generates an EmbeddedDiscretization instance (here, cutgeo). An EmbeddedDiscretization classifies all cells and facets from the background model into inside, outside or cutting the embedded geometry. Cells and facets of the background model outside the embedded geometry play no role in the unfitted formulation, they are inactive, thus it is convenient to remove them and restrict the triangulations to the active portion of the model (i.e., cut and interior cells and facets). In GridapEmbedded we can do this using the classification from cutgeo and the ACTIVE keyword.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Ω_act = Triangulation(cutgeo,ACTIVE)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"To illustrate this concept, we can plot both the background and active triangulations to compare them.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Ω_bg = Triangulation(bgmodel)\nwritevtk(Ω_bg,\"bg_trian\")\nwritevtk(Ω_act,\"act_trian\")","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In the picture below of the background grid, white cells are inactive, whereas gray cells are active.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig2)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"As we will see later, we define our unfitted FE spaces on active triangulations.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"An EmbeddedDiscretization instance (here, cutgeo) also generates subtriangulations on each cut cells to represent the portion of the cell which is inside the domain of analysis. We use these subtriangulations to generate the so called physical triangulations. Physical triangulations are nothing other than a body-fitted mesh of our domain Omega, but we only use them to integrate the weak form of the problem in Omega, we won't define FE spaces and assign DoFs on top of them. In GridapEmbedded we build physical triangulations using the PHYSICAL keyword.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Ω = Triangulation(cutgeo,PHYSICAL)\nwritevtk(Ω,\"phys_trian\")","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Once again, we can combine plots of the physical and active triangulations to illustrate these concepts. In the first plot, we show the physical triangulation within the background one.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig3)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Note that cut cells are subtriangulated to approximate the embedded geometry, as exposed in the following close-up plot.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig4)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In the third plot, we show the region represented by physical triangulation (shaded in gray) embedded in the active grid (black-contoured cells).","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig5)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In a nutshell, to define the unfitted FE formulation of the problem we need the \\\"active\\\" and \\\"physical\\\" triangulations of the domain. The former triangulation is used to define the FE spaces, whereas the latter is used to integrate the weak form. We use a level-set function to derive both of them.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Active Physical\nFor FE spaces For measures\n(Image: fig6) (Image: fig7)","category":"page"},{"location":"pages/t019_unfitted_poisson/#Unfitted-FE-spaces-1","page":"19 Unfitted Poisson","title":"Unfitted FE spaces","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Standard FE methods, i.e. the usual ones for body-fitted meshes, are exposed to the small cut cell problem, which leads to stability and conditioning issues due to the presence of arbitrarily small cut cells. In unfitted FEM, it is impractical to have control over how the mesh intersects the geometry, so we need to treat these numerical issues.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"As said, in this tutorial, we leverage the aggregated unfitted finite element method (AgFEM), see the figure below. The main idea is to remove DoFs on cut cells, whose basis functions potentially have very small local support. In order to do that, we constrain exterior DoFs colorredtimes in terms of interior DOFs colorbluebullet (see figure below) as follows:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We map every exterior DoF colorredtimes to an interior cell tildeK(colorredtimes) of the active triangulation using a cell aggregation scheme (thus the name of the method).\nWe extrapolate the value at the exterior DoF colorredtimes with the local FE basis at the interior cell tildeK(colorredtimes). This leads to:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"  u_colorredtimes = sum_colorbluebulletin tildeK(colorredtimes) varphi_colorbluebullet(x_colorredtimes)u_colorbluebullet quad forall colorredtimes","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Hence, we end up extrapolating exterior DoFs colorredtimes, in terms of interior ones colorbluebullet.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig8)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We define the AgFEM space of our problem as follows. First, we generate a standard linear FE space on the ACTIVE triangulation. We do not prescribe Dirichlet boundaries on the standard FE space for reasons that will be clear later in the tutorial.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nVstd = TestFESpace(Ω_act,reffe,conformity=:H1)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"After this, we construct the aggregates which will be used to build the map of exterior DoFs to interior ones.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"strategy = AggregateAllCutCells()\naggregates = aggregate(strategy,cutgeo)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Note the following remark:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Here, we aggregate all cut cells. Alternatively, we can leave out large enough cut cells using AggregateCutCellsByThreshold(t), where t is a real number. Given a cut cell, if the ratio of the cut region volume and the background cell volume is larger than t, then this cell is not aggregated.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We can color the aggregates and easily inspect them on the background mesh.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"colors = color_aggregates(aggregates,bgmodel)\nΩ_bg = Triangulation(bgmodel)\nwritevtk(Ω_bg,\"aggs_on_bg_trian\",celldata=[\"aggregate\"=>aggregates,\"color\"=>colors])","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Finally, we use the aggregates to constrain the exterior DoFs of Vstd in terms of the interior ones. This leads to the AgFEM space.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"V = AgFEMSpace(Vstd,aggregates)\nU = TrialFESpace(V)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Note that V is a test FE space and the trial FE space U does not receive Dirichlet functions, because we have not prescribed Dirichlet boundaries in the standard test FE space Vstd.","category":"page"},{"location":"pages/t019_unfitted_poisson/#Unfitted-measures-1","page":"19 Unfitted Poisson","title":"Unfitted measures","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We define next the integration measures on the PHYSICAL triangulation.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"degree = 2*order\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Although degree = 2*order is enough for this particular linear case. In general, we need to enforce degree = 2*dim*order on cut cells. This is a detail. We just leave a brief explanation of the reason below.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Since interior cells are rectangular, Fubini theorem applies and we can separate the integrals of the weak form by dimensions. Thus, we can take as quadrature degree 2*order as usual. However, in the case of cut cells, Fubini theorem does not hold. So, to take into account that we cannot separate the integrals, the quadrature degree on cut cells must be premultiplied by the problem dimension, i.e. degree = 2*dim*order.","category":"page"},{"location":"pages/t019_unfitted_poisson/#Imposing-Dirichlet-boundary-conditions-1","page":"19 Unfitted Poisson","title":"Imposing Dirichlet boundary conditions","text":"","category":"section"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"In unfitted FEMs, we cannot impose Dirichlet boundary contions on the Poisson problem as in body-fitted ones. The reason is apparent in the figure below.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We assume a Poisson problem defined on a 2D shape with Dirichlet Gamma_D and Neumann Gamma_N BCs and a close-up on the Dirichlet boundary.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Model problem Body-fitted Unfitted\n(Image: fig9) (Image: fig10) (Image: fig11)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Clearly, on body-fitted meshes, we can impose Dirichlet BCs strongly, i.e. remove the basis functions associated to Dirichlet DoFs from the FE space. On unfitted meshes, we must enforce these conditions weakly. In order to do that we resort to Nitsche's method:","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"beginaligned\na_K(uv) doteq int_Omega cap K nabla u cdot nabla v  mathrmdOmega + int_Gamma_rm D cap K beta_K uv -  (nabla u cdot boldsymboln ) v - (nabla v cdot boldsymboln ) u  mathrmdOmega \nl_K(v) doteq int_Omega cap K f v  mathrmdOmega + int_Gamma_rm N cap K g v  mathrmdGamma + int_Gamma_rm D cap K beta_K u_rm Dv - (nabla v cdot boldsymboln ) u_rm D  mathrmdOmega\nendaligned","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"where beta_K must be large enough to ensure coercivity of the problem.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"This means we need to integrate boundary tems along the embedded boundary. For this purpose we generate the embedded boundary triangulation and measure.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Γ = EmbeddedBoundary(cutgeo)\nn_Γ = get_normal_vector(Γ)\ndΓ = Measure(Γ,degree)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"We can now write the weak form of the problem.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"u(x) = x[1] - x[2] # Solution of the problem\nconst γd = 10.0    # Nitsche coefficient\nconst h = dp[1]/n  # Mesh size according to the parameters of the background grid\n\na(u,v) =\n  ∫( ∇(v)⋅∇(u) )dΩ +\n  ∫( (γd/h)*v*u  - v*(n_Γ⋅∇(u)) - (n_Γ⋅∇(v))*u )dΓ\n\nl(v) = ∫( (γd/h)*v*u - (n_Γ⋅∇(v))*u )dΓ","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Once we have done all this, the rest of the pipeline follows the steps of a standard FE simulation.","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"op = AffineFEOperator(a,l,U,V)\nuh = solve(op)\n\ne = u - uh\n\nl2(u) = sqrt(sum( ∫( u*u )*dΩ ))\nh1(u) = sqrt(sum( ∫( u*u + ∇(u)⋅∇(u) )*dΩ ))\n\nel2 = l2(e)\neh1 = h1(e)\nul2 = l2(uh)\nuh1 = h1(uh)\n\nusing Test\n@test el2/ul2 < 1.e-8\n@test eh1/uh1 < 1.e-7\n\nwritevtk(Ω,\"results.vtu\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"(Image: fig10)","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"Tutorial done!","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"","category":"page"},{"location":"pages/t019_unfitted_poisson/#","page":"19 Unfitted Poisson","title":"19 Unfitted Poisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/TopOptEMFocus.jl\"","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Tutorial-18:-Topology-optimization-1","page":"18 Topology optimization","title":"Tutorial 18: Topology optimization","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"In this tutorial, we will learn:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"How to apply the adjoint method for sensitivity analysis in Gridap\nHow to do topology optimization in Gridap","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We recommend that you first read the Electromagnetic scattering tutorial to make sure you understand the following points:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"How to formulate the weak form for a 2d time-harmonic electromagnetic problem (a scalar Helmholtz equation)\nHow to implement a perfectly matched layer (PML) to absorb outgoing waves\nHow to impose periodic boundary conditions in Gridap\nHow to discretize PDEs with complex-valued solutions","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Problem-statement-1","page":"18 Topology optimization","title":"Problem statement","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Consider the following optimization problem adapted from Christiansen et al. (2020): We want to design a metallic (silver) nanoparticle to focus an incident H_z-polarized planewave on a single spot, maximizing the electric-field intensity at this focal spot.   The metallic structure can be any shape of any topology (any connectivity, number of holes, etcetera) surrounding the focal spot, as long as the metal lies within an annular \"design region\" Omega_d: between a minimum radius r_s = 10nm (the minimum distance from the focal spot) and an outer radius r_d=100nm.  The computational cell is of height H and length L, and we employ a perfectly matched layer (PML) thickness of d_pml to implement outgoing (radiation) boundary conditions for this finite domain. (Image: )","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"The goal is find the arrangement of the silver material in the gray region that maximizes the |electric field|² at the center (the focal point). Every \"pixel\" in the gray region is effectively treated as a degree of freedom that can vary continuously between silver (shown in black below) and air (shown in white below). This is called density-based topology optimization (TO), and leads to a tractable optimization problem despite the huge number of parameters. A standard \"projection\" technique, described below, is used to \"binarize\" the structure by eventually forcing the material to be either silver or air almost everywhere.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Formulation-1","page":"18 Topology optimization","title":"Formulation","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"From Maxwell's equations, considering a time-harmonic electromagnetic field polarized so that the electric field is in-plane and the magnetic field is out-of-plane (described by a scalar H equal to the z-component), we can derive the governing equation of this problem in 2D (Helmholtz equation) [1]:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"left-nablacdotfrac1varepsilon(x)nabla -k^2mu(x)right H = f(x)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"where k=omegac is the wave number in free space and f(x) is the source term (which corresponds to a magnetic current density in Maxwell's equations).","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"In order to simulate this scattering problem in a finite computational domain, we need outgoing (radiation) boundary conditions to prevent waves from reflecting back from the boundaries of the domain.  We employ the well-known technique of \"perfectly matched layers\" (PML) [2], which are an an artificial absorbing layer adjacent to the boundaries that absorbs waves with minimal reflections (going to zero as the resolution increases). The \"stretched-coordinate\" formulation of PML correspond to a simple transformation of the PDE [3]:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"fracpartialpartial xrightarrow frac11+mathrmisigma(u_x)omegafracpartialpartial x","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"fracpartialpartial yrightarrow frac11+mathrmisigma(u_y)omegafracpartialpartial y","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"where u_xy is the depth into the PML, sigma is a profile function (here we chose sigma(u)=sigma_0(ud_pml)^2) and the x and y derivatives correspond PML layers at the x and y boundaries, respectively.  Note that at a finite mesh resolution, PML reflects some waves, and the standard technique to mitigate this is to \"turn on\" the PML absorption gradually—in this case we use a quadratic profile. The amplitude sigma_0 is chosen so that in the limit of infinite resolution the \"round-trip\" normal-incidence is some small number.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Since PML absorbs all waves before they reach the boundary, the associated boundary condition can then be chosen arbitrarily. Here, the boundary conditions are Dirichlet (zero) on the top and bottom sides Gamma_D but periodic on the left (Gamma_L) and right sides (Gamma_R).  The reason that we use periodic boundary conditions for the left and right side instead of Dirichlet boundary conditions is that we want to simulate a plane wave excitation, so we must choose boundary conditions that are satisfied by this incident wave.  (Because of the anisotropic nature of PML, the PML layers at the x boundaries do not disturb an incident planewave traveling purely in the y direction.)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Let mu(x)=1 (materials at optical frequencies have negligible magnetic responses) and denote Lambda=operatornamediagm(Lambda_xLambda_y) where Lambda_xy=frac11+mathrmisigma(u_xy)omega. We can then formulate the problem as","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"left beginaligned\nleft-Lambdanablacdotfrac1varepsilon(x)Lambdanabla -k^2right H = f(x)  text in  Omega\nH=0  text on  Gamma_D\nH_Gamma_L=H_Gamma_R\nendalignedright","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"For convenience in the weak form and Julia implementation below, we represent Lambda as a vector given by the diagonal entries of the 2 times 2 scaling matrix, in which case Lambdanabla becomes the elementwise product.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Topology-Optimization-1","page":"18 Topology optimization","title":"Topology Optimization","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We use density-based topology optimization (TO) to maximize the electric field intensity at the center. In TO, every point in the design domain is a design degree of freedom that can vary continuously between air (p=0) and silver (p=1), which we discretize into a piece-wise constant parameter space P for the design parameter pin 01. The material's electric permittivity ε is then given by:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"varepsilon(p) = leftn_air+p(n_metal-n_air)right^2","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"where n_air=1 and n_metal are the refractive indices (sqrtvarepsilon) of the air and metal, respectively. (It is tempting to simply linearly interpolate the permittivities ε, rather than the refractive indices, but this turns out to lead to artificial singularities in the case of metals where ε can pass through zero [4].)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"In practice, to avoid obtaining arbitrarily fine features as the spatial resolution is increased, one needs to regularize the problem with a minimum lengthscale r_f by generating a smoothed/filtered parameter function p_f.  (Although this regularizes the problem, strictly speaking it does not impose a minimum feature size because of the nonlinear-projection step below. In practical applications, one imposes additional manufacturing constraints explicitly.)  We perform the smoothing p to p_f by solving a simple \"damped diffusion\" PDE, also called a Helmholtz filter [5], for p_f given the design variables p:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"beginaligned\n-r_f^2nabla^2p_f+p_f=p \nleft fracpartial p_fpartial vecn rightvert_partialOmega_D  =0 \nendaligned","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We choose a filter radius r_f=R_f(2sqrt3) where R_f=10 nm, in order to match a published result (using a slightly different filtering scheme) for comparison [6].","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Next, we apply a smoothed threshold projection to the intermediate variable p_f to obtain a \"binarized\" density parameter p_t that tends towards values of 0 or 1 almost everywhere [6] as the steepness beta of the thresholding is increased:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"p_t = fractanh(betaeta)+tanhleftbeta(p_f-eta)righttanh(betaeta)+tanhleftbeta(1-eta)right","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Note that as betatoinfty, this threshold procedure goes to a step function, which would make the optimization problem non-differentiable. In consequence, the standard approach is to gradually increase beta to slowly binarize the design as the optimization progresses [6]. We will show how this is done below.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Finally, we replace p with the filtered and thresholded p_t in the ε interpolation formula from above:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"varepsilon(p_t) = leftn_air+p_t(n_metal-n_air)right^2","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"This is the quantity that will be used for the 1varepsilon(x) coefficient in our Helmholtz PDE.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Weak-form-1","page":"18 Topology optimization","title":"Weak form","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Now we derive the weak form of the PML Helmholtz PDE above. After integration by parts (in which the boundary term vanishes), we obtain:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"a(uvp) = int_Omega leftnabla(Lambda v)cdotfrac1varepsilon(p)Lambdanabla u-k^2uvrightmathrmdOmega","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"b(v) = int_Omega vfmathrmdOmega","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Notice that the nabla(Lambda v) is an element-wise \"product\" of two vectors nabla and Lambda v.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Setup-1","page":"18 Topology optimization","title":"Setup","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We import the packages that will be used, define the geometry and physics parameters.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"using Gridap, Gridap.Geometry, Gridap.Fields, GridapGmsh\nλ = 532      # Wavelength (nm)\nL = 600      # Width of the numerical cell (excluding PML) (nm)\nh1 = 600     # Height of the air region below the source (nm)\nh2 = 200     # Height of the air region above the source (nm)\ndpml = 300   # Thickness of the PML (nm)\n\nn_metal = 0.054 + 3.429im # Silver refractive index at λ = 532 nm\nn_air = 1    # Air refractive index\nμ = 1        # Magnetic permeability\nk = 2*π/λ    # Wavenumber (nm^-1)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Discrete-Model-1","page":"18 Topology optimization","title":"Discrete Model","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We import the model from the RecCirGeometry.msh mesh file using the GmshDiscreteModel function defined in GridapGmsh. The mesh file is created with GMSH in Julia (see the file ../assets/TopOptEMFocus/MeshGenerator.jl). Note that this mesh file already specifies periodic boundaries for the left and right sides, which will cause Gridap to implement periodic boundary conditions. Also, the center smallest-distance circle region is labeled with Center and the annular design region is labeled with Design in the mesh file.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"model = GmshDiscreteModel(\"../models/RecCirGeometry.msh\")","category":"page"},{"location":"pages/t018_TopOptEMFocus/#FE-spaces-for-the-magnetic-field-1","page":"18 Topology optimization","title":"FE spaces for the magnetic field","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We use the first-order Lagrange finite-element basis functions. The Dirichlet edges are labeled as DirichletEdges in the mesh file. Since our problem involves complex numbers (because of the PML and the complex metal refractive index), we need to specify the vector_type as Vector{ComplexF64}.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"order = 1\nreffe = ReferenceFE(lagrangian, Float64, order)\nV = TestFESpace(model, reffe, dirichlet_tags = [\"DirichletEdges\", \"DirichletNodes\"], vector_type = Vector{ComplexF64})\nU = V   # mathematically equivalent to TrialFESpace(V,0)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Numerical-integration-1","page":"18 Topology optimization","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We construct the triangulation and a second-order Gaussian quadrature scheme for assembling the finite-element matrix from the weak form. Note that we create a boundary triangulation from a Source tag for the line excitation, which is a convenient and accurate way to produce an incident planewave. (We could have alternatively devised a corresponding current source, e.g. using a finite-width delta-function approximation.)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"degree = 2\nΩ = Triangulation(model)\ndΩ = Measure(Ω, degree)\n\nΓ_s = BoundaryTriangulation(model; tags = [\"Source\"]) # Source line\ndΓ_s = Measure(Γ_s, degree)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We also want to construct quadrature meshes for the numerical integration over two subsets of the computational cell: the design domain (annulus) Omega_d and the central \"hole\" Omega_c surrounding the focal point. The former is used to localize the design optimization to Omega_d, and the latter is used to define the objective function (which only depends on the field at the center).","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Ω_d = Triangulation(model, tags=\"Design\")\ndΩ_d = Measure(Ω_d, degree)\n\nΩ_c = Triangulation(model, tags=\"Center\")\ndΩ_c = Measure(Ω_c, degree)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#FE-spaces-for-the-design-parameters-1","page":"18 Topology optimization","title":"FE spaces for the design parameters","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"As discussed above, we need a piece-wise constant design parameter space P that is defined in the design domain, this is achieved by a zero-order lagrangian. The number of design parameters is then the number of cells in the design region.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"p_reffe = ReferenceFE(lagrangian, Float64, 0)\nQ = TestFESpace(Ω_d, p_reffe, vector_type = Vector{Float64})\nP = Q\nnp = num_free_dofs(P) # Number of cells in design region (number of design parameters)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Note that this over 70k design parameters, which is large but not huge by modern standards. To optimize so many design parameters, the key point is how to compute the gradients to those parameters efficiently.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Also, we need a first-order lagrangian function space P_f for the filtered parameters p_f since the zero-order lagrangian always produces zero derivatives. (Note that p_f and p_t share the same function space since the latter is only a projection of the previous one.)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"pf_reffe = ReferenceFE(lagrangian, Float64, 1)\nQf = TestFESpace(Ω_d, pf_reffe, vector_type = Vector{Float64})\nPf = Qf","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Finally, we pack up every thing related to gridap as a named tuple called fem_params. This is because we want to pass those as local parameters to the optimization functions later, instead of making them as global parameters.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"fem_params = (; V, U, Q, P, Qf, Pf, np, Ω, dΩ, dΩ_d, dΩ_c, dΓ_s)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#PML-formulation-1","page":"18 Topology optimization","title":"PML formulation","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"First we pack up all physical parameters as a structure call phys. Then we define a s_PML function: s(x)=1+mathrmisigma(u)omega and its derivative ds_PML. The parameter LHp and LHn indicates the size of the inner boundary of the PML regions. Finally, we create a function-like object Λ that returns the PML factors and define its derivative in gridap.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Note that here we are defining a \"callable object\" of type Λ that encapsulates all of the PML parameters. This is convenient, both because we can pass lots of parameters around easily and also because we can define additional methods on Λ, e.g. to express the ∇(Λv) operation.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"R = 1e-10\nLHp=(L/2, h1+h2)   # Start of PML for x,y > 0\nLHn=(L/2, 0)       # Start of PML for x,y < 0\nphys_params = (; k, n_metal, n_air, μ, R, dpml, LHp, LHn)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"PML coordinate streching functions","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"function s_PML(x; phys_params)\n    σ = -3 / 4 * log(phys_params.R) / phys_params.dpml / phys_params.n_air\n    xf = Tuple(x)\n    u = @. ifelse(xf > 0 , xf - phys_params.LHp, - xf - phys_params.LHn)\n    return @. ifelse(u > 0,  1 + (1im * σ / phys_params.k) * (u / phys_params.dpml)^2, $(1.0+0im))\nend\n\nfunction ds_PML(x; phys_params)\n    σ = -3 / 4 * log(phys_params.R) / phys_params.dpml / phys_params.n_air\n    xf = Tuple(x)\n    u = @. ifelse(xf > 0 , xf - phys_params.LHp, - xf - phys_params.LHn)\n    ds = @. ifelse(u > 0, (2im * σ / phys_params.k) * (1 / phys_params.dpml)^2 * u, $(0.0+0im))\n    return ds.*sign.(xf)\nend\n\nstruct Λ{PT} <: Function\n    phys_params::PT\nend\n\nfunction (Λf::Λ)(x)\n    s_x,s_y = s_PML(x; Λf.phys_params)\n    return VectorValue(1/s_x, 1/s_y)\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Define the derivative for the Λ factor","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Fields.∇(Λf::Λ) = x -> TensorValue{2, 2, ComplexF64}(-(Λf(x)[1])^2 * ds_PML(x; Λf.phys_params)[1], 0, 0, -(Λf(x)[2])^2 * ds_PML(x; Λf.phys_params)[2])","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Filter-and-threshold-1","page":"18 Topology optimization","title":"Filter and threshold","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Here we use the filter and threshold dicussed above. The parameters for the filter and threshold are extracted from Ref [6]. Note that every integral in the filter is only defined on Omega_d","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"r = 5/sqrt(3)               # Filter radius\nβ = 32.0                    # β∈[1,∞], threshold sharpness\nη = 0.5                     # η∈[0,1], threshold center\n\na_f(r, u, v) = r^2 * (∇(v) ⋅ ∇(u))\n\nfunction Filter(p0; r, fem_params)\n    ph = FEFunction(fem_params.P, p0)\n    op = AffineFEOperator(fem_params.Pf, fem_params.Qf) do u, v\n        ∫(a_f(r, u, v))fem_params.dΩ_d + ∫(v * u)fem_params.dΩ_d, ∫(v * ph)fem_params.dΩ_d\n      end\n    pfh = solve(op)\n    return get_free_dof_values(pfh)\nend\n\nfunction Threshold(pfh; β, η)\n    return ((tanh(β * η) + tanh(β * (pfh - η))) / (tanh(β * η) + tanh(β * (1.0 - η))))\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Weak-form-2","page":"18 Topology optimization","title":"Weak form","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We notice that the design parameters only affect the weak form in the design domain and the PML does not affect the design domain, we can then make things simpler by dividing the weak form to a base integral that contains the whole computation cell and an additional integral on the design domain. We also make a LU factorization on the final Maxwell operator matrix A since it will only be used to solve for linear equations.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"using LinearAlgebra\nξd(p, n_air, n_metal)= 1 / (n_air + (n_metal - n_air) * p)^2 - 1 / n_air^2 # in the design region\n\na_base(u, v; phys_params) = (1 / phys_params.n_air^2) * ((∇ .* (Λ(phys_params) * v)) ⊙ (Λ(phys_params) .* ∇(u))) - (phys_params.k^2 * phys_params.μ * (v * u))\n\na_design(u, v, pth; phys_params) = ((p -> ξd(p, phys_params.n_air, phys_params.n_metal)) ∘ pth) * (∇(v) ⊙ ∇(u))\n\nfunction MatrixA(pth; phys_params, fem_params)\n    A_mat = assemble_matrix(fem_params.U, fem_params.V) do u, v\n        ∫(a_base(u, v; phys_params))fem_params.dΩ + ∫(a_design(u, v, pth; phys_params))fem_params.dΩ_d\n    end\n    return lu(A_mat)\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Solve-for-plane-wave-incident-1","page":"18 Topology optimization","title":"Solve for plane wave incident","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"The plane wave source b_vec can be simply assembled by a uniform integral over the source line, and the magnetic field vector u_vec can then be solved by a simple linear equation","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"p0 = zeros(fem_params.np)  # Here we make p=0 everywhere just for illustration purpose\npf_vec = Filter(p0;r, fem_params)\npfh = FEFunction(fem_params.Pf, pf_vec)\npth = (pf -> Threshold(pf; β, η)) ∘ pfh\nA_mat = MatrixA(pth; phys_params, fem_params)\nb_vec = assemble_vector(v->(∫(v)fem_params.dΓ_s), fem_params.V)\nu_vec = A_mat \\ b_vec\nuh = FEFunction(fem_params.U, u_vec)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Objective-1","page":"18 Topology optimization","title":"Objective","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"The problem is maximizing the electric field intensity at the center. Recall that the electric field can be retrieved from the magnetic field by","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"mathbfE(mathbfx)=fracmathrmiomegavarepsilon(mathbfx)nablatimesmathbfH(mathbfx)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"and our objective is the field intensity at center vertmathbfE(mathbfx_0)vert^2.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"In the 2D formulation, this objective can be simplified to","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"g = int vertnabla Hvert^2delta(x-x_0)mathrmdOmega = u^dagger Ou","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"where u is the magnetic field vector and","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"O = int (nabla hatvcdotnablahatu)delta(x-x_0)mathrmdOmega","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"with hatv and hatu are the finite element basis functions.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"In practice, the delta function can be approximated by a concentrated Gaussian function. Note that we use dΩ_c here in order to reduce computation costs.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"function MatrixOf(fem_params)\n    x0 = VectorValue(0,300)  # Position of the field to be optimized\n    δ = 1\n    return assemble_matrix(fem_params.U, fem_params.V) do u, v\n        ∫((x->(1/(2*π)*exp(-norm(x - x0)^2 / 2 / δ^2))) * (∇(u) ⋅ ∇(v)) )fem_params.dΩ_c\n    end\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Optimization-with-adjoint-method-1","page":"18 Topology optimization","title":"Optimization with adjoint method","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Now that we have our objective to optimize, the next step is to find out the derivative to the desigin parameter p in order to apply a gradient-based optimization algorithm. We will be using ChainRulesCore and Zygote packages.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"using ChainRulesCore, Zygote\nimport ChainRulesCore: rrule\nNO_FIELDS = ZeroTangent()","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Recall that our objective is g=u^dagger Ou and only u=A(p)^-1 b depends on the design parameters. The derivative of g with respect to p_t can be obtained via adjoint method:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"fracmathrmd gmathrmdp_t= -2Releftw^daggerleft(fracmathrmdAmathrmdp_turight)right","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"where w comes from the adjoint solve A^dagger w = Ou. The final derivative with respect to p can then be obtained via chain rules:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"fracmathrmd gmathrmdp=fracmathrmd gmathrmdp_tcdotfracmathrmd p_tmathrmdp_fcdotfracmathrmd p_fmathrmdp","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"First we define some relative derivative functions:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Dptdpf(pf, β, η) = β * (1.0 - tanh(β * (pf - η))^2) / (tanh(β * η) + tanh(β * (1.0 - η)))\n\nDξdpf(pf, n_air, n_metal, β, η)= 2 * (n_air - n_metal) / (n_air + (n_metal - n_air) * Threshold(pf; β, η))^3 * Dptdpf(pf, β, η)\n\nDAdpf(u, v, pfh; phys_params, β, η) = ((p -> Dξdpf(p, phys_params.n_air, phys_params.n_metal, β, η)) ∘ pfh) * (∇(v) ⊙ ∇(u))","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Then we create a function gf_pf that depends directly on p_f and write out the derivate using adjoint method formula. Note that the threshold chainrule is already implemented in the functions above.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"function gf_pf(pf_vec; β, η, phys_params, fem_params)\n    pfh = FEFunction(fem_params.Pf, pf_vec)\n    pth = (pf -> Threshold(pf; β, η)) ∘ pfh\n    A_mat = MatrixA(pth; phys_params, fem_params)\n    b_vec = assemble_vector(v->(∫(v)fem_params.dΓ_s), fem_params.V)\n    u_vec = A_mat \\ b_vec\n\n    O_mat = MatrixOf(fem_params)\n    real(u_vec' * O_mat * u_vec)\nend\n\nfunction rrule(::typeof(gf_pf), pf_vec; β, η, phys_params, fem_params)\n    function U_pullback(dgdg)\n      NO_FIELDS, dgdg * Dgfdpf(pf_vec; β, η, phys_params, fem_params)\n    end\n    gf_pf(pf_vec; β, η, phys_params, fem_params), U_pullback\nend\n\nfunction Dgfdpf(pf_vec; β, η, phys_params, fem_params)\n    pfh = FEFunction(fem_params.Pf, pf_vec)\n    pth = (pf -> Threshold(pf; β, η)) ∘ pfh\n    A_mat = MatrixA(pth; phys_params, fem_params)\n    b_vec = assemble_vector(v->(∫(v)fem_params.dΓ_s), fem_params.V)\n    u_vec = A_mat \\ b_vec\n    O_mat = MatrixOf(fem_params)\n\n    uh = FEFunction(fem_params.U, u_vec)\n    w_vec =  A_mat' \\ (O_mat * u_vec)\n    wconjh = FEFunction(fem_params.U, conj(w_vec))\n\n    l_temp(dp) = ∫(real(-2 * DAdpf(uh, wconjh, pfh; phys_params, β, η)) * dp)fem_params.dΩ_d\n    dgfdpf = assemble_vector(l_temp, fem_params.Pf)\n    return dgfdpf\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Next we define the relation between p_f and p, and obtain the derivative of the filter by again applying an adjoint method:","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"function pf_p0(p0; r, fem_params)\n    pf_vec = Filter(p0; r, fem_params)\n    pf_vec\nend\n\nfunction rrule(::typeof(pf_p0), p0; r, fem_params)\n  function pf_pullback(dgdpf)\n    NO_FIELDS, Dgdp(dgdpf; r, fem_params)\n  end\n  pf_p0(p0; r, fem_params), pf_pullback\nend\n\nfunction Dgdp(dgdpf; r, fem_params)\n    Af = assemble_matrix(fem_params.Pf, fem_params.Qf) do u, v\n        ∫(a_f(r, u, v))fem_params.dΩ_d + ∫(v * u)fem_params.dΩ_d\n    end\n    wvec = Af' \\ dgdpf\n    wh = FEFunction(fem_params.Pf, wvec)\n    l_temp(dp) = ∫(wh * dp)fem_params.dΩ_d\n    return assemble_vector(l_temp, fem_params.P)\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Finally, we pack up into a single function that takes p and returns our objective function, and which can optionally take a grad vector into which the gradient (computed by Zygote by composing our rules above) can be written in-place (as required for use in the NLopt optimization package). We also optionally record the value of the objective function from every call in order to save a record of the optimization process.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"function gf_p(p0::Vector; r, β, η, phys_params, fem_params)\n    pf_vec = pf_p0(p0; r, fem_params)\n    gf_pf(pf_vec; β, η, phys_params, fem_params)\nend\n\nfunction gf_p(p0::Vector, grad::Vector; r, β, η, phys_params, fem_params)\n    if length(grad) > 0\n        dgdp, = Zygote.gradient(p -> gf_p(p; r, β, η, phys_params, fem_params), p0)\n        grad[:] = dgdp\n    end\n    gvalue = gf_p(p0::Vector; r, β, η, phys_params, fem_params)\n    open(\"gvalue.txt\", \"a\") do io\n        write(io, \"$gvalue \\n\")\n    end\n    gvalue\nend","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Using the following codes, we can check if we can get the derivatives correctly from the adjoint method by comparing it with the finite difference results.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"p0 = rand(fem_params.np)\nδp = rand(fem_params.np)*1e-8\ngrad = zeros(fem_params.np)\n\ng0 = gf_p(p0, grad; r, β, η, phys_params, fem_params)\ng1 = gf_p(p0+δp, []; r, β, η, phys_params, fem_params)\ng1-g0, grad'*δp","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Optimization-with-NLopt-1","page":"18 Topology optimization","title":"Optimization with  NLopt","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"Now we use NLopt.jl package to implement the MMA algorithm for optimization. Note that we start with beta=8 and then gradually increase it to beta=32 in consistant with Ref. [6].","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"using NLopt\n\nfunction gf_p_optimize(p_init; r, β, η, TOL = 1e-4, MAX_ITER = 500, phys_params, fem_params)\n    ##################### Optimize #################\n    opt = Opt(:LD_MMA, fem_params.np)\n    opt.lower_bounds = 0\n    opt.upper_bounds = 1\n    opt.ftol_rel = TOL\n    opt.maxeval = MAX_ITER\n    opt.max_objective = (p0, grad) -> gf_p(p0, grad; r, β, η, phys_params, fem_params)\n\n    (g_opt, p_opt, ret) = optimize(opt, p_init)\n    @show numevals = opt.numevals # the number of function evaluations\n    return g_opt, p_opt\nend\n\np_opt = fill(0.4, fem_params.np)   # Initial guess\nβ_list = [8.0, 16.0, 32.0]\n\ng_opt = 0\nTOL = 1e-8\nMAX_ITER = 100\nfor bi = 1 : 3\n    β = β_list[bi]\n    g_opt, p_temp_opt = gf_p_optimize(p_opt; r, β, η, TOL, MAX_ITER, phys_params, fem_params)\n    global p_opt = p_temp_opt\nend\n@show g_opt","category":"page"},{"location":"pages/t018_TopOptEMFocus/#Results-and-plot-1","page":"18 Topology optimization","title":"Results and plot","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"We use the CairoMakie.jl and GridapMakie.jl packages to plot the field as well as the optimized shape. Note that there might be multiple local optima for this problem, so different initial guesses might result in different optimized shapes.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"using CairoMakie, GridapMakie\np0 = p_opt\n\npf_vec = pf_p0(p0; r, fem_params)\npfh = FEFunction(fem_params.Pf, pf_vec)\npth = (pf -> Threshold(pf; β, η)) ∘ pfh\nA_mat = MatrixA(pth; phys_params, fem_params)\nb_vec = assemble_vector(v->(∫(v)fem_params.dΓ_s), fem_params.V)\nu_vec = A_mat \\ b_vec\nuh = FEFunction(fem_params.U, u_vec)\n\nfig, ax, plt = plot(fem_params.Ω, pth, colormap = :binary)\nColorbar(fig[1,2], plt)\nax.aspect = AxisAspect(1)\nax.title = \"Design Shape\"\nrplot = 110 # Region for plot\nlimits!(ax, -rplot, rplot, (h1)/2-rplot, (h1)/2+rplot)\nsave(\"shape.png\", fig)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"(Image: )","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"For the electric field, recall that vert Evert^2simvert frac1epsilonnabla Hvert^2, the factor 2 below comes from the amplitude compared to the incident plane wave. We can see that the optimized shapes are very similiar to the optimized shape in Ref. [6], proving our results.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"maxe = 30 # Maximum electric field magnitude compared to the incident plane wave\ne1=abs2(phys_params.n_air^2)\ne2=abs2(phys_params.n_metal^2)\n\nfig, ax, plt = plot(fem_params.Ω, 2*(sqrt∘(abs((conj(∇(uh)) ⋅ ∇(uh))/(CellField(e1,fem_params.Ω) + (e2 - e1) * pth)))), colormap = :hot, colorrange=(0, maxe))\nColorbar(fig[1,2], plt)\nax.title = \"|E|\"\nax.aspect = AxisAspect(1)\nlimits!(ax, -rplot, rplot, (h1)/2-rplot, (h1)/2+rplot)\nsave(\"Field.png\", fig)","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"(Image: )","category":"page"},{"location":"pages/t018_TopOptEMFocus/#References-1","page":"18 Topology optimization","title":"References","text":"","category":"section"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[1] Wikipedia: Electromagnetic wave equation","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[2] Wikipedia: Perfectly matched layer","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[3] A. Oskooi and S. G. Johnson, “Distinguishing correct from incorrect PML proposals and a corrected unsplit PML for anisotropic, dispersive media,” Journal of Computational Physics, vol. 230, pp. 2369–2377, April 2011.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[4] R. E. Christiansen, J. Vester-Petersen, S.P. Madsen, and O. Sigmund, “A non-linear material interpolation for design of metallic nano-particles using topology optimization,” Computer Methods in Applied Mechanics and Engineering , vol. 343, pp. 23–39, January 2019.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[5] B. S. Lazarov and O. Sigmund, \"Filters in topology optimization based on Helmholtz-type differential equations\", International Journal for Numerical Methods in Engineering, vol. 86, pp. 765-781, December 2010.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"[6] R.E. Christiansen, J. Michon, M. Benzaouia, O. Sigmund, and S.G. Johnson, \"Inverse design of nanoparticles for enhanced Raman scattering,\" Optical Express, vol. 28, pp. 4444-4462, Feburary 2020.","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"","category":"page"},{"location":"pages/t018_TopOptEMFocus/#","page":"18 Topology optimization","title":"18 Topology optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/elasticity.jl\"","category":"page"},{"location":"pages/t003_elasticity/#Tutorial-3:-Linear-elasticity-1","page":"3 Linear elasticity","title":"Tutorial 3: Linear elasticity","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"How to approximate vector-valued problems\nHow to solve problems with complex constitutive laws\nHow to impose Dirichlet boundary conditions only in selected components\nHow to impose Dirichlet boundary conditions described by more than one function","category":"page"},{"location":"pages/t003_elasticity/#Problem-statement-1","page":"3 Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we detail how to solve a linear elasticity problem defined on the 3D domain depicted in next figure.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We impose the following boundary conditions. All components of the displacement vector  are constrained to zero on the surface Gamma_rm G, which is marked in green in the figure. On the other hand, the first component of the displacement vector is prescribed to the value deltadoteq 5mm on the surface Gamma_rm B, which is marked in blue. No body or surface forces are included in this example. Formally, the PDE to solve is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"leftlbrace\nbeginaligned\n-cdotsigma(u) = 0  textin  Omega\nu = 0  texton Gamma_rm G\nu_1 = delta  texton Gamma_rm B\nsigma(u)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The variable u stands for the unknown displacement vector, the vector n is the unit outward normal to the Neumann boundary Gamma_rm NdoteqpartialOmegasetminusleft(Gamma_rm BcupGamma_rm Gright) and sigma(u) is the stress tensor defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"sigma(u) doteq lambda rm tr(varepsilon(u))  I +2 mu   varepsilon(u)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"where I is the 2nd order identity tensor, and lambda and mu are the Lamé parameters of the material. The operator varepsilon(u)doteqfrac12left(nabla u + (nabla u)^t right) is the symmetric gradient operator (i.e., the strain tensor). Here, we consider material parameters corresponding to aluminum with Young's modulus E=70cdot 10^9 Pa and Poisson's ratio nu=033. From these values, the Lamé parameters are obtained as lambda = (Enu)((1+nu)(1-2nu)) and mu=E(2(1+nu)).","category":"page"},{"location":"pages/t003_elasticity/#Numerical-scheme-1","page":"3 Linear elasticity","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"As in previous tutorial, we use a conventional Galerkin FE method with conforming Lagrangian FE spaces. For this formulation, the weak form is: find uin U such that $ a(u,v) = 0 $ for all vin V_0, where U is the subset of functions in VdoteqH^1(Omega)^3 that fulfill the Dirichlet boundary conditions of the problem, whereas V_0 are functions in V fulfilling v=0 on Gamma_rm G and v_1=0 on Gamma_rm B. The bilinear form of the problem is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(uv)doteq int_Omega varepsilon(v)  sigma(u)  rm dOmega","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The main differences with respect to previous tutorial is that we need to deal with a vector-valued problem, we need to impose different prescribed values on the Dirichlet boundary, and the integrand of the bilinear form a(cdotcdot) is more complex as it involves the symmetric gradient operator and the stress tensor. However, the implementation of this numerical scheme is still done in a user-friendly way since all these features can be easily accounted for with the abstractions in the library.","category":"page"},{"location":"pages/t003_elasticity/#Discrete-model-1","page":"3 Linear elasticity","title":"Discrete model","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We start by loading the discrete model from a file","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"using Gridap\nmodel = DiscreteModelFromFile(\"../models/solid.json\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In order to inspect it, write the model to vtk","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"and open the resulting files with Paraview. The boundaries Gamma_rm B and Gamma_rm G are identified  with the names \"surface_1\" and \"surface_2\" respectively.  For instance, if you visualize the faces of the model and color them by the field \"surface_2\" (see next figure), you will see that only the faces on Gamma_rm G have a value different from zero.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Vector-valued-FE-space-1","page":"3 Linear elasticity","title":"Vector-valued FE space","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The next step is the construction of the FE space. Here, we need to build a vector-valued FE space, which is done as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"order = 1\n\nreffe = ReferenceFE(lagrangian,VectorValue{3,Float64},order)\nV0 = TestFESpace(model,reffe;\n  conformity=:H1,\n  dirichlet_tags=[\"surface_1\",\"surface_2\"],\n  dirichlet_masks=[(true,false,false), (true,true,true)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"As in previous tutorial, we construct a continuous Lagrangian interpolation of order 1. The vector-valued interpolation is selected via the option valuetype=VectorValue{3,Float64}, where we use the type VectorValue{3,Float64}, which is the way Gridap represents vectors of three Float64 components. We mark as Dirichlet the objects identified with the tags \"surface_1\" and \"surface_2\" using the dirichlet_tags argument. Finally, we chose which components of the displacement are actually constrained on the Dirichlet boundary via the dirichlet_masks argument. Note that we constrain only the first component on the boundary Gamma_rm B (identified as \"surface_1\"), whereas we constrain all components on Gamma_rm G (identified as \"surface_2\").","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The construction of the trial space is slightly different in this case. The Dirichlet boundary conditions are described with two different functions, one for boundary Gamma_rm B and another one for Gamma_rm G. These functions can be defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"g1(x) = VectorValue(0.005,0.0,0.0)\ng2(x) = VectorValue(0.0,0.0,0.0)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"From functions g1 and g2, we define the trial space as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"U = TrialFESpace(V0,[g1,g2])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that the functions g1 and g2 are passed to the TrialFESpace constructor in the same order as the boundary identifiers are passed previously in the dirichlet_tags argument of the TestFESpace constructor.","category":"page"},{"location":"pages/t003_elasticity/#Constitutive-law-1","page":"3 Linear elasticity","title":"Constitutive law","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the FE spaces are defined, the next step is to define the weak form.  In this example, the construction of the weak form requires more work than in previous tutorial since we need to account for the constitutive law that relates strain and stress.  The symmetric gradient operator is represented by the function ε provided by Gridap (also available as symmetric_gradient). However, function σ representing the stress tensor is not predefined in the library and it has to be defined ad-hoc by the user, namely","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const E = 70.0e9\nconst ν = 0.33\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\nσ(ε) = λ*tr(ε)*one(ε) + 2*μ*ε","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Function σ takes a strain tensor ε(one can interpret this strain as the strain at an arbitrary integration point) and computes the associated stress tensor using the Lamé operator.  Note that the implementation of function σ is very close to its mathematical definition.","category":"page"},{"location":"pages/t003_elasticity/#Weak-form-1","page":"3 Linear elasticity","title":"Weak form","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"As seen in previous tutorials, in order to define the weak form we need to build the integration mesh and the corresponding measure","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"degree = 2*order\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"From these objects and the constitutive law previously defined, we can write the weak form as follows","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(u,v) = ∫( ε(v) ⊙ (σ∘ε(u)) )*dΩ\nl(v) = 0","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that we have composed function σ with the strain field ε(u) in order to compute the stress field associated with the trial function u. The linear form is simply l(v) = 0 since there are not external forces in this example.","category":"page"},{"location":"pages/t003_elasticity/#Solution-of-the-FE-problem-1","page":"3 Linear elasticity","title":"Solution of the FE problem","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The remaining steps for solving the FE problem are essentially the same as in previous tutorial.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"op = AffineFEOperator(a,l,U,V0)\nuh = solve(op)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that we do not have explicitly constructed a LinearFESolver in order to solve the FE problem. If a LinearFESolver is not passed to the solve function, a default solver (LU factorization) is created and used internally.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Finally, we write the results to a file. Note that we also include the strain and stress tensors into the results file.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(Ω,\"results\",cellfields=[\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ∘ε(uh)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"It can be clearly observed (see next figure) that the surface  Gamma_rm B is pulled in x_1-direction and that the solid deforms accordingly.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Multi-material-problems-1","page":"3 Linear elasticity","title":"Multi-material problems","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We end this tutorial by extending previous code to deal with multi-material problems. Let us assume that the piece simulated before is now made of 2 different materials (see next figure). In particular, we assume that the volume depicted in dark green is made of aluminum, whereas the volume marked in purple is made of steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The two different material volumes are properly identified in the model we have previously loaded. To check this, inspect the model with Paraview (by writing it to vtk format as done before). Note that the volume made of aluminum is identified as \"material_1\", whereas the volume made of steel is identified as \"material_2\".","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In order to build the constitutive law for the bi-material problem, we need a vector that contains information about the material each cell in the model is composed. This is achieved by these lines","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"using Gridap.Geometry\nlabels = get_face_labeling(model)\ndimension = 3\ntags = get_face_tag(labels,dimension)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Previous lines generate a vector, namely tags, whose length is the number of cells in the model and for each cell contains an integer that identifies the material of the cell.  This is almost what we need. We also need to know which is the integer value associated with each material. E.g., the integer value associated with \"material_1\" (i.e. aluminum) is retrieved as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const alu_tag = get_tag_from_name(labels,\"material_1\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Now, we know that cells whose corresponding value in the tags vector is alu_tag are made of aluminum, otherwise they are made of steel (since there are only two materials in this example).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we are ready to define the multi-material constitutive law. First, we define the material parameters for aluminum and steel respectively:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"function lame_parameters(E,ν)\n  λ = (E*ν)/((1+ν)*(1-2*ν))\n  μ = E/(2*(1+ν))\n  (λ, μ)\nend\n\nconst E_alu = 70.0e9\nconst ν_alu = 0.33\nconst (λ_alu,μ_alu) = lame_parameters(E_alu,ν_alu)\n\nconst E_steel = 200.0e9\nconst ν_steel = 0.33\nconst (λ_steel,μ_steel) = lame_parameters(E_steel,ν_steel)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Then, we define the function containing the constitutive law:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"function σ_bimat(ε,tag)\n  if tag == alu_tag\n    return λ_alu*tr(ε)*one(ε) + 2*μ_alu*ε\n  else\n    return λ_steel*tr(ε)*one(ε) + 2*μ_steel*ε\n  end\nend","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that in this new version of the constitutive law, we have included a third argument that represents the integer value associated with a certain material. If the value corresponds to the one for aluminum (i.e., tag == alu_tag), then, we use the constitutive law for this material, otherwise, we use the law for steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Since we have constructed a new constitutive law, we need to re-define the bilinear form of the problem:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(u,v) = ∫( ε(v) ⊙ (σ_bimat∘(ε(u),tags)) )*dΩ","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In previous line, pay attention in the usage of the new constitutive law σ_bimat. Note that we have passed the vector tags containing the material identifiers in the last argument of the function`.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we can build the FE problem again and solve it","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"op = AffineFEOperator(a,l,U,V0)\nuh = solve(op)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the solution is computed, we can store the results in a file for visualization. Note that, we are including the stress tensor in the file (computed with the bi-material law).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(Ω,\"results_bimat\",cellfields=\n  [\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ_bimat∘(ε(uh),tags)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Tutorial done!","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/validation_DrWatson.jl\"","category":"page"},{"location":"pages/t014_validation_DrWatson/#Tutorial-14:-On-using-DrWatson.jl-1","page":"14 On using DrWatson.jl","title":"Tutorial 14: On using DrWatson.jl","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"How to use DrWatson.jl to accelerate and reproduce our Gridap simulation workflows","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"DrWatson.jl is a Julia package that helps managing a typical scientific workflow thorought all its phases, see a summary here.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"All its functionalities can be accessed with (non-invasive) simple function calls.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"In order to illustrate how to benefit from DrWatson.jl in Gridap.jl simulations, we refactor here the convergence test from the Code validation tutorial.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Instead of implementing a helper function to carry out the convergence test, we will generate them using DrWatson.jl functions.","category":"page"},{"location":"pages/t014_validation_DrWatson/#.-Activate-your-project-1","page":"14 On using DrWatson.jl","title":"1. Activate your project","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"The first step is to activate our project using quickactivate. This does not only activate the project, it also sets the relative paths within the project, so you can safely use the functions projectdir() and its derivatives datadir(), plotsdir(), srcdir(), etc. Beware of this warning, you must activate the project before using other packages.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"using DrWatson\n@quickactivate \"Tutorials\"","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Although this tutorial is already in a Project (and git repo), we could also start our scientific project from scratch with DrWatson.jl, using function initialize_project. This function initiates, on the working directory, (1) a git repo with a folder structure enriched for scientific workflows, e.g. folders data, plots, papers, etc., and (2)Project.toml and Manifest.toml files. More details here.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Once the project is activated, we ensure that all packages we use have the versions dictated by our activated project.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"using Gridap\nimport Gridap: ∇","category":"page"},{"location":"pages/t014_validation_DrWatson/#.-Prepare-the-simulations-1","page":"14 On using DrWatson.jl","title":"2. Prepare the simulations","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We consider the Poisson equation in the unit square Omegadoteq (01)^2 as a model problem,","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We are going to perform a convergence test with the manufactured solution u(x) = x_1^3 + x_2^3.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"To this end, we want to solve our computational model for many combinations of mesh size and order of FE approximation (parameters) and extract the L2- and H1-norm errors (output data).","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We first group all parameters and parameter values in a single ditionary","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"params = Dict(\n  \"cells_per_axis\" => [8,16,32,64],\n  \"fe_order\" => [1,2]\n)","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"and then we use DrWatson's dict_list to expand all the parameters into a vector of dictionaries. Each dictionary contains the parameter-value combinations corresponding to a single simulation case.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"dicts = dict_list(params)","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Warning! Be careful when combining parameters of different value type. You may end up with dictionaries that do not have a concrete type and experience a significant type-inference overhead when running the simulations.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We wrap next in a function a run of our computational model for a single pair (cells_per_axis,fe_order). The function returns the L2- and H1-error norms.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We define the manufactured function, as usual","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"p = 3\nu(x) = x[1]^p+x[2]^p\n∇u(x) = VectorValue(p*x[1]^(p-1),p*x[2]^(p-1))\nf(x) = -p*(p-1)*(x[1]^(p-2)+x[2]^(p-2))\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"And the function that runs a single case of our parametric space reads","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"function run(n::Int,k::Int)\n\n  domain = (0,1,0,1)\n  partition = (n,n)\n  model = CartesianDiscreteModel(domain,partition)\n\n  reffe = ReferenceFE(lagrangian,Float64,k)\n  V0 = TestFESpace(model,reffe,conformity=:H1,dirichlet_tags=\"boundary\")\n  U = TrialFESpace(V0,u)\n\n  degree = 2*p\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,degree)\n\n  a(u,v) = ∫( ∇(u)⊙∇(v) ) * dΩ\n  b(v) = ∫( v*f ) * dΩ\n\n  op = AffineFEOperator(a,b,U,V0)\n\n  uh = solve(op)\n\n  e = u - uh\n\n  el2 = sqrt(sum( ∫( e*e )*dΩ ))\n  eh1 = sqrt(sum( ∫( e*e + ∇(e)⋅∇(e) )*dΩ ))\n\n  (el2, eh1)\n\nend","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"In order to communicate with DrWatson.jl helper functions, we need to add an extra layer on top of run, such that the input and output are dictionaries.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Note the use of functions @unpack and @dict to decompose and compose the dictionaries. You can check in DrWatson.jl's documentation further functions to manipulate dictionaries.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"function run(case::Dict)\n  @unpack cells_per_axis, fe_order = case\n  el2, eh1 = run(cells_per_axis,fe_order)\n  h = 1.0/cells_per_axis\n  results = @strdict el2 eh1 h\n  merge(case,results)\nend","category":"page"},{"location":"pages/t014_validation_DrWatson/#.-Run-and-save-1","page":"14 On using DrWatson.jl","title":"3. Run and save","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"While running the simulations, we need to save the results. DrWatson.jl frees you from the burden of generating the filenames for each case. For this purpose, it provides the functions savename, @tagsave or produceorload, among others.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Among them, we recommend using produceorload. The special feature of this function is that it checks whether the file containing the output data of the case already exists. If that happens, then the function loads the file, instead of running the case. In this way, we avoid repeating simulations that have already been run.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Thus, in order to run all simulation cases, it suffices to map all cases in dicts to the produce_or_load function:","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"function run_or_load(case::Dict)\n  produce_or_load(\n    projectdir(\"assets\",\"validation_DrWatson\"),\n    case,\n    run,\n    prefix=\"res\",\n    tag=true,\n    verbose=true\n  )\n  return true\nend\n\nmap(run_or_load,dicts)","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Note that the results of each case are stored in a binary database file in the projectdir(\"assets\",\"validation_DrWatson\") folder. Each result file stores the output dictionary that returns from run(case).","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We also observe that we set tag=true in produce_or_load. This option is key to preserve reproducibility. It adds to the output dictionary the field :gitcommit, thus allowing us to trace the status of the code, at which we obtained those results. Furthermore, if the git repo is dirty, one more field :gitpatch is added, storing the difference string.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"In some situations, you will prefer to repeat all simulations and track their evolution as you change the code. To this end, check out safesave.","category":"page"},{"location":"pages/t014_validation_DrWatson/#.-Listing-the-simulations-1","page":"14 On using DrWatson.jl","title":"4. Listing the simulations","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Results stored by DrWatson.jl in databases are handled with the DataFrames.jl package, a powerful Julia package to manipulate tabular data.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"using DataFrames","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"To collect all simulation results, it suffices to use the collect_results! function from DrWatson.jl from the folder where the results are stored.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"df = collect_results(projectdir(\"assets\",\"validation_DrWatson\"))","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"We order next the database by (ascending) mesh size and we extract the arrays of mesh sizes and errors","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"sort!(df,:h)\nhs = df[(df.fe_order .== 1),:h]\nel2s1 = df[(df.fe_order .== 1),:el2]\neh1s1 = df[(df.fe_order .== 1),:eh1]\nel2s2 = df[(df.fe_order .== 2),:el2]\neh1s2 = df[(df.fe_order .== 2),:eh1]","category":"page"},{"location":"pages/t014_validation_DrWatson/#.-Generate-the-plot-1","page":"14 On using DrWatson.jl","title":"5. Generate the plot","text":"","category":"section"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"With the generated data, we do the classical convergence plot and interpret it in the same way as in the validation tutorial.","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"using Plots\n\nplot(hs,[el2s1 eh1s1 el2s2 eh1s2],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2 k=1\" \"H1 k=1\" \"L2 k=2\" \"H1 k=2\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"If you run the code in a notebook, you will see a figure like this one: (Image: )","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"Congrats, another tutorial done!","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"If you use DrWatson.jl in a scientific project that leads to a publication, please do not forget to cite the paper associated with it:","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"@article{Datseris2020,\n doi = {10.21105/joss.02673},\n url = {https://doi.org/10.21105/joss.02673},\n year = {2020},\n publisher = {The Open Journal},\n volume = {5},\n number = {54},\n pages = {2673},\n author = {George Datseris and Jonas Isensee and Sebastian Pech and Tamás Gál},\n title = {DrWatson: the perfect sidekick for your scientific inquiries},\n journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"","category":"page"},{"location":"pages/t014_validation_DrWatson/#","page":"14 On using DrWatson.jl","title":"14 On using DrWatson.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the tutorial pages of the Gridap.jl project.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"},{"location":"#How-to-start-1","page":"Introduction","title":"How to start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"There are different ways to use the tutorials:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"[Recommended] Reading the html version of the tutorials. This is the recommended way if you want rapid access to the material with no setup steps. Simply click in one of the links in the Contents section.\n[Recommended] Running the Jupyter notebooks locally. A working installation of Julia in the system is required. See instructions in the How to run the notebooks locally section. This is the recommended way to follow the tutorials if you want to run the code and inspect the generated results with Paraview.\nRunning the notebook remotely via binder. In that case, go to the desired tutorial and click the icon (Image: ). No local installation of Julia needed.\nReading a non-interactive version of the notebook via nbviewer. In that case, go to the desired tutorial and click the icon (Image: )","category":"page"},{"location":"#How-to-run-the-notebooks-locally-1","page":"Introduction","title":"How to run the notebooks locally","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Clone the repository","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git clone https://github.com/gridap/Tutorials.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Move into the folder and open a Julia REPL setting the current folder as the project environment. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ cd Tutorials\n$ julia --project=.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Instantiate the environment. This will automatically download all required packages.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\n(Tutorials) pkg> instantiate","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Build the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using IJulia\njulia> notebook(dir=pwd())","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This will open a browser window. Navigate to the notebooks folder and open the tutorial you want. Enjoy!","category":"page"},{"location":"#How-to-pull-the-latest-version-of-the-tutorials-1","page":"Introduction","title":"How to pull the latest version of the tutorials","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have cloned the repository a while ago, you can update to the newest version with these steps.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Go to the Tutorials repo folder and git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open Julia REPL","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ julia --project=.\n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and instantiate the environment and build the notebooks again","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\n(Tutorials) pkg> instantiate\n\n# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Done!","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/poisson_distributed.jl\"","category":"page"},{"location":"pages/t016_poisson_distributed/#Tutorial-16:-Poisson-equation-on-parallel-distributed-memory-computers-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"Tutorial 16: Poisson equation on parallel distributed-memory computers","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t016_poisson_distributed/#Introduction-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"Introduction","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"In this tutorial we will learn how to use GridapDistributed.jl and its satellite packages, GridapP4est.jl, GridapGmsh.jl, and GridapPETSc.jl, in order to solve a Poisson PDE problem  on the unit square using grad-conforming Lagrangian Finite Elements for numerical discretization.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"We will first solve the problem using solely the built-in tools in GridapDistributed.jl. While this is very useful for testing and debugging purposes, GridapDistributed.jl is not a library of parallel solvers. Indeed, the built-in linear solver kernel within GridapDistributed.jl, defined with the backslash operator \\, is just a sparse LU solver applied to the global system gathered on a master task (thus not scalable). To address this, we will then illustrate which changes are required in the program to replace the built-in solver in GridapDistributed.jl by GridapPETSc.jl. This latter package provides the full set of scalable linear and nonlinear solvers in the PETSc numerical package.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"On the other hand, in real-world applications, one typically needs to solve PDEs on more complex domains than simple boxes. To this end, we can leverage either GridapGmsh.jl, in order to partition and distribute automatically unstructured meshes read from disk in gmsh format, or GridapP4est.jl, which allows one to mesh in a very scalable way computational domains which can be decomposed as forests of octrees. The last part of the tutorial will present the necessary changes in the program in order to use these packages.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"IMPORTANT NOTE: the parallel codes in this tutorial depend on the Message Passing Interface (MPI). Thus, they cannot be easily executed interactively, e.g., in a Jupyter notebook. Instead, one has to run them from a terminal using the mpiexecjl script as provided by MPI.jl, e.g., with the command mpiexecjl --project=. -n 4 julia src/poisson_distributed.jl run from the root directory of the Tutorials git repository.","category":"page"},{"location":"pages/t016_poisson_distributed/#First-example:-GridapDistributed.jl-built-in-tools-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"First example: GridapDistributed.jl built-in tools","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"using Gridap\nusing GridapDistributed\nusing PartitionedArrays","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"The first step in any GridapDistributed.jl program is to define a function (named main_ex1 below) to be executed on each part on which the domain is distributed. This function receives a single argument (named parts below). The body of this function is equivalent to a sequential Gridap script, except for the CartesianDiscreteModel call, which in GridapDistributed also requires the parts argument passed to the main_ex1 function. The domain is discretized using the parallel Cartesian-like mesh generator built-in in GridapDistributed.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"function main_ex1(parts)\n  domain = (0,1,0,1)\n  mesh_partition = (4,4)\n  model = CartesianDiscreteModel(parts,domain,mesh_partition)\n  order = 2\n  u((x,y)) = (x+y)^order\n  f(x) = -Δ(u,x)\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = TestFESpace(model,reffe,dirichlet_tags=\"boundary\")\n  U = TrialFESpace(u,V)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,2*order)\n  a(u,v) = ∫( ∇(v)⋅∇(u) )dΩ\n  l(v) = ∫( v*f )dΩ\n  op = AffineFEOperator(a,l,U,V)\n  uh = solve(op)\n  writevtk(Ω,\"results_ex1\",cellfields=[\"uh\"=>uh,\"grad_uh\"=>∇(uh)])\nend","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"Once the main_ex1 function has been defined, we have to trigger its execution on the different parts. To this end, one calls the with_backend function of PartitionedArrays.jl right at the beginning of the program.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"partition = (2,2)\nwith_backend(main_ex1, MPIBackend(), partition)","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"With this function, the programmer sets up the PartitionedArrays.jl communication backend (i.e., MPI in the example), specifies the number of parts and their layout (i.e., 2x2 Cartesian-like mesh partition in the example), and provides the main_ex1 function to be run on each part.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"Although not illustrated in this tutorial, we note that one may also use the SequentialBackend() PartitionedArrays.jl backend, instead of MPIBackend(). With this backend, the code executes serially on a single process (and there is thus no need to use mpiexecjl to launch the program), although  the data structures are still partitioned into parts. This is very useful, among others, for interactive execution of the code, and debugging, before moving to MPI parallelism.","category":"page"},{"location":"pages/t016_poisson_distributed/#Second-example:-GridapDistributed.jl-GridapPETSc.jl-for-the-linear-solver-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"Second example: GridapDistributed.jl + GridapPETSc.jl for the linear solver","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"using GridapPETSc","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"In this example we use GridapPETSc.jl to have access to a scalable linear solver. The code is almost identical as the one above (see below). The main difference is that now we are wrapping most of the code of the main_ex2 function within a do-block syntax function call to the GridapPETSc.with(args=split(options)) function. The with function receives as a first argument a function with no arguments with the instructions to be executed on each MPI task/subdomain (that we pass to it as an anonymous function with no arguments), along with the options to be passed to the PETSc linear solver. For a detailed explanation of possible options we refer to the PETSc library documentation. Note that the call to PETScLinearSolver() initializes the PETSc solver with these options (even though options is not actually passed to the linear solver constructor). Besides, we have to pass the created linear solver object solver to the solve function to override the default linear solver (i.e., a call to the backslash \\ Julia operator).","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"function main_ex2(parts)\n  options = \"-ksp_type cg -pc_type gamg -ksp_monitor\"\n  GridapPETSc.with(args=split(options)) do\n    domain = (0,1,0,1)\n    mesh_partition = (4,4)\n    model = CartesianDiscreteModel(parts,domain,mesh_partition)\n    order = 2\n    u((x,y)) = (x+y)^order\n    f(x) = -Δ(u,x)\n    reffe = ReferenceFE(lagrangian,Float64,order)\n    V = TestFESpace(model,reffe,dirichlet_tags=\"boundary\")\n    U = TrialFESpace(u,V)\n    Ω = Triangulation(model)\n    dΩ = Measure(Ω,2*order)\n    a(u,v) = ∫( ∇(v)⋅∇(u) )dΩ\n    l(v) = ∫( v*f )dΩ\n    op = AffineFEOperator(a,l,U,V)\n    solver = PETScLinearSolver()\n    uh = solve(solver,op)\n    writevtk(Ω,\"results_ex2\",cellfields=[\"uh\"=>uh,\"grad_uh\"=>∇(uh)])\n  end\nend\n\npartition = (2,2)\nwith_backend(main_ex2, MPIBackend(), partition)","category":"page"},{"location":"pages/t016_poisson_distributed/#Third-example:-second-example-GridapP4est.jl-for-mesh-generation-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"Third example: second example + GridapP4est.jl for mesh generation","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"In this example, we define the Cartesian mesh using GridapP4est.jl via recursive uniform refinement starting with a single cell. It only involves minor modifications compared to the previous example. First, one has to generate a coarse mesh of the domain. As the domain is a just a simple box in the example, it suffices to use a coarse mesh with a single quadrilateral fitted to the box in order to capture the geometry of the domain with no geometrical error (see how the coarse_discrete_model object is generated). In more complex scenarios, one can read an unstructured coarse mesh from disk, generated, e.g., with an unstructured brick mesh generator. Second, when building the fine mesh of the domain (see UniformlyRefinedForestOfOctreesDiscreteModel call), one has to specify the number of uniform refinements to be performed on the coarse mesh in order to generate the fine mesh. Finally, when calling with_backend, we do not longer specify a Cartesian partition but just the number of parts.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"using GridapP4est\n\nfunction main_ex3(parts)\n  options = \"-ksp_type cg -pc_type gamg -ksp_monitor\"\n  GridapPETSc.with(args=split(options)) do\n    domain = (0,1,0,1)\n    coarse_mesh_partition = (1,1)\n    num_uniform_refinements=2\n    coarse_discrete_model=CartesianDiscreteModel(domain,coarse_mesh_partition)\n    model=UniformlyRefinedForestOfOctreesDiscreteModel(parts,\n                                                       coarse_discrete_model,\n                                                       num_uniform_refinements)\n    order = 2\n    u((x,y)) = (x+y)^order\n    f(x) = -Δ(u,x)\n    reffe = ReferenceFE(lagrangian,Float64,order)\n    V = TestFESpace(model,reffe,dirichlet_tags=\"boundary\")\n    U = TrialFESpace(u,V)\n    Ω = Triangulation(model)\n    dΩ = Measure(Ω,2*order)\n    a(u,v) = ∫( ∇(v)⋅∇(u) )dΩ\n    l(v) = ∫( v*f )dΩ\n    op = AffineFEOperator(a,l,U,V)\n    solver = PETScLinearSolver()\n    uh = solve(solver,op)\n    writevtk(Ω,\"results_ex3\",cellfields=[\"uh\"=>uh,\"grad_uh\"=>∇(uh)])\n  end\nend\n\nnparts = 4\nwith_backend(main_ex3, MPIBackend(), nparts)","category":"page"},{"location":"pages/t016_poisson_distributed/#Fourth-example:-second-example-GridapGmsh.jl-for-mesh-generation-1","page":"16 Poisson equation on parallel distributed-memory computers","title":"Fourth example: second example + GridapGmsh.jl for mesh generation","text":"","category":"section"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"In this example, we want to use an unstructured mesh. The mesh is read from disk and partitioned/distributed automatically by GridapGmsh inside the call to the GmshDiscreteModel constructor.","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"using GridapGmsh\nfunction main_ex4(parts)\n  options = \"-ksp_type cg -pc_type gamg -ksp_monitor\"\n  GridapPETSc.with(args=split(options)) do\n    model = GmshDiscreteModel(parts,\"../models/demo.msh\")\n    order = 2\n    u((x,y)) = (x+y)^order\n    f(x) = -Δ(u,x)\n    reffe = ReferenceFE(lagrangian,Float64,order)\n    V = TestFESpace(model,reffe,dirichlet_tags=[\"boundary1\",\"boundary2\"])\n    U = TrialFESpace(u,V)\n    Ω = Triangulation(model)\n    dΩ = Measure(Ω,2*order)\n    a(u,v) = ∫( ∇(v)⋅∇(u) )dΩ\n    l(v) = ∫( v*f )dΩ\n    op = AffineFEOperator(a,l,U,V)\n    solver = PETScLinearSolver()\n    uh = solve(solver,op)\n    writevtk(Ω,\"results_ex4\",cellfields=[\"uh\"=>uh,\"grad_uh\"=>∇(uh)])\n  end\nend\n\nnparts = 4\nwith_backend(main_ex4, MPIBackend(), nparts)","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"","category":"page"},{"location":"pages/t016_poisson_distributed/#","page":"16 Poisson equation on parallel distributed-memory computers","title":"16 Poisson equation on parallel distributed-memory computers","text":"This page was generated using Literate.jl.","category":"page"}]
}
